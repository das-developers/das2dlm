/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */
 
/*
;+
; FUNCTION:
;  das2c_physdims
;
; PURPOSE:
;  List the physical dimensions represented in a das2 dataset.
;
; CALLING SEQUENCE:
;  Result = das2c_physdims(query_id, ds_index, pdim)
;
; INPUTS:
;  query_id: The identification integer for the stored query result as
;            returned by das2c_readhttp() or das2c_queries.
;
;  ds_index: The dataset index, often 0.  See das2c_datasets() for details.
;
; OPTIONAL INPUTS:
;  pdim:     Either the physical dimension index (long), or the dimension's
;            name (string).  This input is only required if information
;            concerting a single physical dimension is desired.  
;            	
;            Dimension names are somewhat standardized.  For example time tags
;            are usually in dimension 'time' and energy bin centers are
;            typically in a dimension named 'energy'.  Application code
;            shouldn't depend on this fact but it may use the standardized
;            names as plotting hints.
;
; OUTPUT:
;  This function returns an array of structures providing an overview of
;  each stored result.  Output structures have the fields:
;
;    'idx':      Long    ; The index of this dataset, starts from 0
;    'name':     String  ; The name of this physical dimension, ex: 'time'
;    'vars':     Long    ; The number of variables carring data values for this
;                        ; physical dimension.
;    'props':    Long    ; The number of metadata properties for this dimension
;    'size':     Long64  ; The total number of values in the variables for 
;                        ; this dimension
;
; EXAMPLES:
;  List summary information on all physical dimensions for dataset 0 in
;  query result 27
;    das2c_physdims(27, 0)
;
;  List summary information on the time dimension in the same dataset.
;    das2c_physdims(27, 0, 'time')
;
;  List summary information on the dimension that happens to live at index 0.
;    das2c_physdims(27, 0, 0)
;
; MODIFICATION HISTORY:
;  Written by: Chris Piker, 2020-03-09
;-
*/

/* Output structure definition */
static IDL_STRUCT_TAG_DEF _das2c_physdim_tags[] = {
	{"idx",      0, (void*)IDL_TYP_LONG},
	{"name",     0, (void*)IDL_TYP_STRING},
	{"vars",     0, (void*)IDL_TYP_LONG},
	{"props",    0, (void*)IDL_TYP_LONG},
	{"size",     0, (void*)IDL_TYP_LONG64},
	{0}
};	

typedef struct _das2c_pdim_sum{
	IDL_LONG   idx;
	IDL_STRING name;
	IDL_LONG   vars;
	IDL_LONG   props;
	IDL_LONG64 size;
} das2c_PdimSummary;

#define D2C_PHYSDIMS_MINA 2
#define D2C_PHYSDIMS_MAXA 3
#define D2C_PHYSDIMS_FLAG 0

static IDL_StructDefPtr g_das2c_pPdimSumDef;

static void DAS2C_PHYSDIM_def()
{
	g_das2c_pPdimSumDef = IDL_MakeStruct("DAS2C_PHYSDIM", _das2c_physdim_tags);
}

static IDL_VPTR das2c_physdims(int argc, IDL_VPTR* argv)
{
	/* Check args exist */
	if(argc < 1) das2c_IdlMsgExit("Query ID not provided");	
	
	/* Get check Query ID */
	int iQueryId;
	IDL_VPTR pTmpVar = NULL;
	pTmpVar = IDL_BasicTypeConversion(1, argv, IDL_TYP_LONG);
	iQueryId = pTmpVar->value.l;
	IDL_DELTMP(pTmpVar);
	
	const DasIdlDbEnt* pEnt = das2c_db_getent(iQueryId);
	if(pEnt == NULL)
		das2c_IdlMsgExit("No query result has ID %d", iQueryId);
	
	/* Get/check dataset ID */
	int iDs;
	if(argc < 2) das2c_IdlMsgExit("Dataset index not provided");
	pTmpVar = IDL_BasicTypeConversion(1, argv+1, IDL_TYP_LONG);
	iDs = pTmpVar->value.l;
	IDL_DELTMP(pTmpVar);
	if(iDs < 0) das2c_IdlMsgExit("Invalid dataset index %d", iDs);
	
	if(iDs >= pEnt->uDs){
		if(pEnt->uDs == 0)
			das2c_IdlMsgExit(
				"Query result %d doesn't contain any datasets", iQueryId
			);
		else
			das2c_IdlMsgExit(
				"Query result %d dataset indices are 0 to %zu", 
				iQueryId, pEnt->uDs - 1
			);
	}
	const DasDs* pDs = pEnt->lDs[iDs];
	if(pDs == NULL) das2c_IdlMsgExit("Logic error, das2c_datasets.c");
	
	
	/* Get the dimension in question, or assume they want to know about
	 * all of them. */
	const DasDim* pTheDim = NULL;
	int iTmp = -1;
	const char* sDim = NULL;
	
	if(argc > 2){
		/* See if this is as string */
		if(argv[2]->type == IDL_TYP_STRING){
			sDim = IDL_VarGetString(argv[2]);
			
			if(*sDim == '\0') das2c_IdlMsgExit("Dimension name is empty");
			
			pTheDim = DasDs_getDimById(pDs, sDim);
						
			das2c_IdlMsgExit(
				"Query result %d, dataset %d doesn't have a physical dimension"
				" namesd '%s'", iQueryId, iDs, sDim
			);	
		}
		else{
			pTmpVar = IDL_BasicTypeConversion(1, argv + 2, IDL_TYP_LONG);
			iTmp = pTmpVar->value.l;
			IDL_DELTMP(pTmpVar);
			if((iTmp < 0)||(iTmp > pDs->uDims)) 
				das2c_IdlMsgExit("Invalid physical dimension index %d", iTmp);
			
			pTheDim = pDs->lDims[iTmp];
		}
	}
	
	IDL_MEMINT dims = 1;
	if(pTheDim == NULL) dims = pDs->uDims;
	
	IDL_VPTR pRet;  /* the to-be-returned structure */
	
	/* Returns pRet->value.s.arr.data */
	das2c_PdimSummary* pData = (das2c_PdimSummary*) IDL_MakeTempStruct(
		g_das2c_pPdimSumDef,   /* The opaque structure definition */
		1,                   /* Number of dimesions */
		&dims,               /* Size of each dimension, (only one dimension) */
		&pRet,               /* The actual structure variable */
		TRUE                 /* Zero out the array */
	);

	const DasDim* pIterDim = NULL;
	const DasVar* pVar = NULL;
	const DasAry* pAry = NULL;
	size_t uVar = 0;
	
	for(size_t u = 0; u < pDs->uDims; ++u){
		pIterDim = pDs->lDims[u];
		if(pIterDim == NULL) das2c_IdlMsgExit("Logic error, das2c_physdims.c");
		
		/* If we have a constant dim to report on and this ain't it, skip */
		if((pTheDim != NULL)&&(pIterDim != pTheDim)) continue;

		/* Write into IDL memory using parallel structure pointer */
		
		/* TODO:  Consider adding a DasDim_getPointVar() call to flatten
		          waveform data. */
		pData->idx      = u;
		pData->vars     = pIterDim->uVars;
		pData->props    = DasDesc_length((DasDesc*)pIterDim);
		
		if(DasDim_id(pIterDim) != NULL) 
			IDL_StrStore(&(pData->name), DasDim_id(pIterDim));
		
		pData->size = 0;
		for(uVar = 0; uVar < pIterDim->uVars; ++uVar){
			pVar = pIterDim->aVars[uVar];
			
			/* see if this variable is backed by an array */
			if( (pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
				pData->size += DasAry_size(pAry);
		}
		
		if(pTheDim != NULL) break;
		++pData;
	}
	
	return pRet;
}

