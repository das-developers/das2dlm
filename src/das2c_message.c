/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

 #define DASIDL_ERR_MSG_SZ 1024

/* Define message codes and their corresponding printf(3) format strings. 
   Note that message codes start at zero and each one is one less that the
	previous one. Codes must be monotonic and contiguous. */
static IDL_MSG_DEF msg_arr[] = {
#define M_TM_BAD 0
	{ "M_TM_BAD", "%NSomething bad happened" },

#define M_TM_GOOD -1
	{ "M_TM_GOOD", "%NSomething good happened"}
};

/* The load function fills in this message block handle with the opaque handle
   to the message block used for this module. Th other routines can then use
	it to throw errors from this block.  */

static IDL_MSG_BLOCK msg_block;


/* Syntax sugar for bailing out with a message */
void das2c_IdlMsgExit(const char* sFmt, ...){
	char sBuf[1024] = {'\0'};
	
	va_list argp;
	
	va_start(argp, sFmt);
	vsnprintf(sBuf, 1023, sFmt, argp);
	va_end(argp);
	
	IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, sBuf);
}


/* ************************************************************************* */
/* Provides mechanism to copy out errors to IDL, must be invoked manually.   */

#define ERROR2IDL_BUFSZ DASIDL_ERR_MSG_SZ + 256 + 64 + 64

static void das2c_error2idl()
{
	das_error_msg* pMsg = das_get_error();
	if(pMsg == NULL) return;
	
	char sErrBuf[ERROR2IDL_BUFSZ] = {'\0'};
	
	snprintf(
		sErrBuf, ERROR2IDL_BUFSZ - 1,
		"%s\n(Reported from %s in %s:%d)",
		pMsg->message, pMsg->sFunc, pMsg->sFile, pMsg->nLine
	);
	
	das_error_free(pMsg);
	
	/* It appears that IDL_Message is not a standard varargs function.
	   Providing %s and then the string results in no output.
		
	   To get around this, give it the buffer directly, but for safety, convert
		any % characters to $ so that there cannot be any formatting 
		information.  Hoeky I known, but it prevents error messages  
		triggering an interpreter crash. 
	*/
	for(int i = 0; i < strlen(sErrBuf); ++i)
		if(sErrBuf[i] == '%') sErrBuf[i] = '$';
	
	IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, sErrBuf);
}


/* ************************************************************************* */
/* Bounce logs and errors to IDL                                             */

#define LOG2IDL_BUFSZ 1024
static void das2c_log2idl(int nLevel, const char* sMsg, bool bPrnTime)
{
	/* No need for thread safety in here, only called from das_log which
	   locks a mutex */
	const char* sLvl;
	char buf[32];
	char sTime[32];
#ifndef _WIN32
	struct tm bdTime;
#endif
	time_t tEpoch;
	buf[31] = '\0';
	sTime[31] = '\0';
	
	char sOutMsg[LOG2IDL_BUFSZ] = {'\0'};

	switch(nLevel){
		case DASLOG_TRACE: sLvl = "TRACE"; break;
		case DASLOG_DEBUG: sLvl = "DEBUG"; break;
		case DASLOG_INFO:  sLvl = "INFO"; break;
		case DASLOG_WARN:  sLvl = "WARNING"; break;
		case DASLOG_ERROR: sLvl = "ERROR"; break;
		case DASLOG_CRIT:  sLvl = "CRITICAL"; break;
		default:
			snprintf(buf, 31, "LEVEL %d MSG", nLevel); sLvl = buf; break;
	}

	if(bPrnTime){
		tEpoch = time(NULL);
#ifdef _WIN32
		/* Note: localtime is thread safe on win32, see note:
		 * http://sources.redhat.com/ml/pthreads-win32/2005/msg00011.html
		 */
		strftime(sTime, 31, "%Y-%m-%dT%H:%M:%S", localtime( &tEpoch));
#else
		strftime(sTime, 31, "%Y-%m-%dT%H:%M:%S", localtime_r( &tEpoch, &bdTime));
#endif

		snprintf(sOutMsg, LOG2IDL_BUFSZ - 1, "(%s, %s) ", sTime, sLvl);
	}
	else{
		snprintf(sOutMsg, LOG2IDL_BUFSZ - 1, "%s: ", sLvl);
	}
	snprintf(sOutMsg, LOG2IDL_BUFSZ - 1, "%s\n", sMsg);
	
	/* Treat all logs as info.  If the problem is bad enough we'll pop
	   an error which does get displayed even with !QUIET */
	IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_INFO, sOutMsg);
}


/* TODO: Add bindings to log level manipulation functions. */

