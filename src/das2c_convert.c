/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

#define D2C_CONVERT_MINA 2
#define D2C_CONVERT_MAXA 2
#define D2C_CONVERT_FLAG 0

/*
;+
; FUNCTION:
;  das2c_convert
;
; PURPOSE:
;  Rewrite variable data in a new set of units including epoch times
;
; CALLING SEQUENCE:
;  Result = das2c_convert(var, new_units)
;  Result = das2c_convert(var, new_units, factor)
;
; INPUTS:
;  var:       A DAS2C_VAR structure as returned by das2c_vars()
;
;  new_units: A UTF-8 string providing the requested units.  Generic SI unit
;             conversions are provide as well an converting times from one set
;             of intervals-from-epoch units to another.  The canonical unit 
;             representation is taken from the PDS3 standard which use Frotran
;             exponetial notation.  For example, electric spectral density is
;             given as:
; 
;               V**2 m**-2 Hz**-1
;
;             Though the '^' character is understood for eponentiation and the
;             '/' character inverts the exponent sign for all following units.
;             At this time, bracket '[]', parentesis '()' and brace '{}' are
;             not understood and result in a parse error.
;
;             All standard SI unit names are understood except 'candela'.  All
;             standard SI symbols are understood except 'cd'.  All standard SI
;             prefixes are also understood from 'y' (yocto) up to  'Y' (yotta).
;
;             Special non-SI strings have the meanings given below, most of
;             these have to do with time and date handling.
;
;             'mj1958' - Days since 1958-01-01T00:00
;             't1970'  - Seconds since 1970-01-01T00:00:00 ignoring leap seconds
;             't2000'  - Seconds since 2001-01-01T00:00:00 ignoring leap seconds
;             'us2000' - Micorseconds since 2001-01-01T00:00 ignoring leap seconds
;             'ns1970' - Nanoseconds since 1970-01-01T00:00:00 ignoring leap seconds
;             'UTC'    - Broken down time fields, ethier strings or structures
;
;             'day','days' - An interval of 86400 seconds
;             'hr','hour','hours' - An interval of 3600 seconds
;             'min','miute','minutes' - An interval of 60 seconds
;
;             Strings that are not recognized as SI units or special time units
;             such as 'feet', 'cows', 'trucks', and 'donuts' are acceptable.  
;             These may have SI prefixes which are manipulatable by this
;             function but are otherwise not interpreted.
;
; OPTIONAL INPUTS:
;  factor:    A multiplicitve factor to blindly apply to the data.  If this is
;             provided the new units are saved as the unit string and internal
;             arrays are adjusted accordingly.
;
; OUTPUT:
;  A string giving the canonical form of the new units.
;
; EXAMPLES:
;  Insure time-center values for a variable are in the Unix epoch of t1970:
;   
;    das2c_convert(v_time, 't1970')
;
;  Convert distance data in km to the unknown unit 'AU'.  Since das2c doesn't
;  know about astronomical units, we'll have to provide the conversion factor
;  as well:
;
;    das2c_convert(R_sun, 'AU', 149597870.7)
;
;  Convert variable data in units of 'cows' to 'μcows' thus multiplying all
;  internal values by 1e+6:
;
;    das2c_convert(v_capacity, 'μcows')
;
;  Convert data in units of 'donuts/day' to the more SI appropriate 'donut Hz':
;    
;    das2c_convert(v_sales, 'donut Hz')
;
; MODIFICATION HISTORY:
;  In progress
;-
*/

static IDL_VPTR das2c_api_convert(int argc, IDL_VPTR* argv)
{
	
	DasVar* pVar = das2c_arg_to_var(argc, argv, 0, NULL, NULL, NULL, NULL);
	
	/* Get new units */
	if(argc < 2)
		das2c_IdlMsgExit("Units not given in for argument 2");
	
	if(argv[1]->type != IDL_TYP_STRING)
		das2c_IdlMsgExit("Units string exected for argument 2");

	const char* sNewUnits = IDL_VarGetString(argv[1]);
	if(*sNewUnits == '\0') das2c_IdlMsgExit("Units string is empty");
	
	das_units new_units = Units_fromStr(sNewUnits);
	if(new_units == UNIT_INVALID)
		das2c_error2idl();
	
	if(! Units_canConvert(pVar->units, new_units) )
		das2c_IdlMsgExit(
			"Data in units of %s can't be converted to units of %s",
			Units_toStr(pVar->units), sNewUnits
		);
	
	/* See if this variable has an array, if not there's no need to run 
	   conversions here. */
	if(pVar->vartype != D2V_ARRAY)
		das2c_IdlMsgError(
			"Unit conversions for virtual variables and sequences is not yet supported."
		);

	DasAry* pAry = DasVarAry_getArray(pVar);
	if(pAry == NULL) das2c_IdlMsgError("das2C logic error in DasVarAry_getArray()");
	
	/* get a pointer to the top of the variable and get it's length, ignore the
	   shape, we don't care for this operation. */
	size_t u = 0, uVals = 0;
	const byte* pSrc = DasAry_getIn(pAry, pVar-vt, DIM0, &uVals);
	
	/* For time units we just have to run the function on everything (slow)
	   for non-time units we can get a factor and convert in a loop (fast) */
	if(Units_haveCalRep(new_units)){
		/* TODO:  Update das2C to provide a function to get the factor and
		   the displacement so that times can be converted in a loop as well */	
		
		
	}
	else{
		double rFactor = Units_convertTo(
			
	}
	
	
}

