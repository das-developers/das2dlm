/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

static IDL_STRUCT_TAG_DEF DAS_TIME_tags[] = {
   {"YEAR",   NULL,  (void*)IDL_TYP_LONG},
	{"MONTH",  NULL,  (void*)IDL_TYP_LONG},
	{"MDAY",   NULL,  (void*)IDL_TYP_LONG},
	{"YDAY",   NULL,  (void*)IDL_TYP_LONG},
	{"HOUR",   NULL,  (void*)IDL_TYP_LONG},
	{"MINUTE", NULL,  (void*)IDL_TYP_LONG},
	{"SECOND", NULL,  (void*)IDL_TYP_DOUBLE},
	{0}
};

/* DAS2C_TIME_data struct already defined. It is just the das_time from das2C.
	The tags above supply the IDL definition. */
#define DAS_TIME_data das_time

static IDL_StructDefPtr DAS_TIME_pdef;

static void define_DAS_TIME()
{
	DAS_TIME_pdef = IDL_MakeStruct("DAS_TIME", DAS_TIME_tags);
}

int das2c_vtype_2_idlcode(das_val_type vt)
{
	switch(vt){
	case vtUnknown: return IDL_TYP_BYTE;  /* Must state length somehow */
	case vtByte:    return IDL_TYP_BYTE;
	case vtUShort:  return IDL_TYP_UINT;
	case vtShort:   return IDL_TYP_INT;
	case vtInt:     return IDL_TYP_LONG;
	case vtLong:    return IDL_TYP_LONG64;
	case vtFloat:   return IDL_TYP_FLOAT;
	case vtDouble:  return IDL_TYP_DOUBLE;
	case vtTime:    return IDL_TYP_STRUCT;
	case vtText:    return IDL_TYP_STRING;
	default: return IDL_TYP_UNDEF;
	}	
}

static const int g_nHiBit_UINT = sizeof(IDL_UINT)*8 - 1;
static const int g_nHiBit_ULONG = sizeof(IDL_UINT)*8 - 1;
static const int g_nHiBit_ULONG64 = sizeof(IDL_UINT)*8 - 1;


static bool _das2c_addrSzCompat(UCHAR type, UCHAR* pData)
{
	const char* sTypeMsg = "Integer type larger than machine memary address type";
	const char* sRngMsg  = "Index value larger than maximum machine memory address";
	
	/* Only throw errors for types that should normally work */
	switch(type){
	case IDL_TYP_INT:
		if(sizeof(IDL_INT) <= sizeof(ptrdiff_t)) return true;
		das2c_IdlMsgExit(sTypeMsg);
		break;
				 
	case IDL_TYP_LONG:
		if(sizeof(IDL_LONG) <= sizeof(ptrdiff_t)) return true;
		das2c_IdlMsgExit(sTypeMsg);
		break;
		 
	case IDL_TYP_LONG64:
		if(sizeof(IDL_LONG64) <= sizeof(ptrdiff_t)) return true;
		das2c_IdlMsgExit(sTypeMsg);
		break;
	
	/* Unsigned values must be less than 1/2 SIZE_MAX.  basically the 
	   highest bit can't be 1 */
	
	case IDL_TYP_UINT:
		if(sizeof(IDL_UINT) <= sizeof(ptrdiff_t)){
			if( (*((IDL_UINT*)pData) >> g_nHiBit_UINT)&0x1 )
				das2c_IdlMsgExit(sRngMsg);
			 return true;
		}
		das2c_IdlMsgExit(sTypeMsg);
		break; 
		
	case IDL_TYP_ULONG:
		if(sizeof(IDL_ULONG) <= sizeof(ptrdiff_t)){
			if( (*((IDL_ULONG*)pData) >> g_nHiBit_UINT)&0x1 )
				das2c_IdlMsgExit(sRngMsg);
			 return true;
		}
		das2c_IdlMsgExit(sTypeMsg);
		break; 
		
	case IDL_TYP_ULONG64:
		if(sizeof(IDL_ULONG64) <= sizeof(ptrdiff_t)){
			if( (*((IDL_ULONG64*)pData) >> g_nHiBit_UINT)&0x1 )
				das2c_IdlMsgExit(sRngMsg);
			 return true;
		}
		das2c_IdlMsgExit(sTypeMsg);
		break; 
		
	default:
		return false;
	}
	return false;  /* make dumb compilers happy */
}

ptrdiff_t _das2c_toOffset(UCHAR type, UCHAR* pData)
{
	ptrdiff_t nTmp = 0;
	
	switch(type){
	case IDL_TYP_INT:     nTmp = *((IDL_INT*)pData);  break;
	case IDL_TYP_LONG:    nTmp = *((IDL_LONG*)pData);  break;	
	case IDL_TYP_LONG64:  nTmp = *((IDL_LONG64*)pData);  break;	
	case IDL_TYP_UINT:    nTmp = *((IDL_UINT*)pData);  break;	
	case IDL_TYP_ULONG:   nTmp = *((IDL_ULONG*)pData);  break;
	case IDL_TYP_ULONG64: nTmp = *((IDL_ULONG64*)pData);  break;	
	default:
		das2c_IdlMsgExit("Type not usable as an index");
		break;
	}
	return nTmp;
}

/* ************************************************************************* */
/* Extract ranges from an IDL structure */

/* A check in das2c for the value of IDL_MAX_ARRAY_DIM insures these
   arrays are long enough */
static const char* g_sLowerIdx[IDL_MAX_ARRAY_DIM] = {
	"i", "j", "k", "l", "m", "n", "o", "p"
};
static const char* g_sUpperIdx[IDL_MAX_ARRAY_DIM] = {
	"I", "J", "K", "L", "M", "N", "O", "P"
};

void _das2c_data_setrng(
	const ptrdiff_t* aShape, ptrdiff_t* aMin, ptrdiff_t* aMax, int r,
	IDL_VPTR pStruct
){
	IDL_VPTR pTagDesc = NULL;
	
	/* IDL interface should use const more often to make meaning clear */
	IDL_MEMINT nTagOffset = IDL_StructTagInfoByName(
		pStruct->value.s.sdef, (char*)g_sUpperIdx[r], IDL_MSG_RET, &pTagDesc
	);
	if(nTagOffset == -1){
		nTagOffset = IDL_StructTagInfoByName(
			pStruct->value.s.sdef, (char*)g_sLowerIdx[r], IDL_MSG_RET, &pTagDesc
		);	
	}
	if(nTagOffset == -1) return;
	
	UCHAR* pValData = pStruct->value.s.arr->data + nTagOffset;
	const char* sVal = NULL;
	
	if(pTagDesc->flags & IDL_V_ARR){
		
		if((pTagDesc->value.arr->n_elts) != 2)
			das2c_IdlMsgExit("For index %s, range array should be two values long",
				g_sUpperIdx[r]
			);
		
		/* Lower bound */
		if(!_das2c_addrSzCompat(pTagDesc->type, pValData)){
			das2c_IdlMsgExit("Expected an integer type for lower %s index",
				g_sUpperIdx[r]
			);
		}
		else{
			aMin[r] = _das2c_toOffset(pTagDesc->type, pValData);
			if(aMin[r] < 0) aMin[r] = aShape[r] - aMin[r];
		}
		
		/* Upper Bound */
		pValData += pTagDesc->value.arr->elt_len;
		
		if(!_das2c_addrSzCompat(pTagDesc->type, pValData)){
			das2c_IdlMsgExit("Expected an integer type for upper %s index", 
				g_sUpperIdx[r]
			);
		}
		else{
			aMax[r] = _das2c_toOffset(pTagDesc->type, pValData);
			if(aMax[r] < 0) aMax[r] = aShape[r] - aMax[r];
		}
	}
	
	/* Single integer value */
	if(_das2c_addrSzCompat(pTagDesc->type, pValData)){
		aMin[r] = _das2c_toOffset(pTagDesc->type, pValData);
		if(aMin[r] < 0) aMin[r] = aShape[r] - aMin[r];
		
		/* Bug here, if aMin is = 2^31 this will fail on 32-bit machines */
		/* of course they would have lots of other problems first I'd imagine */
		aMax[r] = aMin[r] + 1;
		return;
	}
	
	/* The only supported string is '*', which is just syntax sugar */
	if(pTagDesc->type == IDL_TYP_STRING){
		
		sVal = IDL_STRING_STR( (IDL_STRING*)pValData );
		if(strcmp(sVal, "*") != 0){
			das2c_IdlMsgExit("String '%s' not understood for %s index range", 
				sVal, g_sUpperIdx[r]
			);
		}
		return;
	}
		
	das2c_IdlMsgExit(
		"Value for index %s is not understood, must be '*', a single integer"
		" of any type or an array of two integers of any type."
	);               
}

/* Mostly a hook for double free debugging */

void _das2c_data_free(UCHAR* ptr)
{
	free((void*)ptr);
}

/* ************************************************************************* */
/* API Function, careful with changes! */

#define D2C_DATA_MINA 1
#define D2C_DATA_MAXA 2
#define D2C_DATA_FLAG 0

/*
;+
; FUNCTION:
;  das2c_data
;
; PURPOSE:
;  Get data arrays from das2 variables
;
; CALLING SEQUENCE:
;  Result = das2c_data(var)
;  Result = das2c_data(var, slice)
;
; INPUTS:
;  var:  A DAS2C_VAR structure as returned by das2c_vars()
;
; OPTIONAL INPUTS:
;  slice: An anoymous structure providing a sub range in index space.  By 
;         default das2c_data() returns an array that has the same extent in
;         index space as the overall dataset (see DAS2C_DSET.SHAPE).  This
;         makes it easy to plot data as all correlated values, no matter the
;         underlying storage format, appear at the exact same index set.
; 
;         To save output memory, or when working with a subset of the data, a
;         slice structure be provided which has the following fields:
; 
;           I - The location in the left-most (fastest moving) index.
;           J - The location in the next to fastest moving index
; 
;          ... and so on up to the letter 'P'.
; 
;          The following example specifies a single point in an 8 dimensional
;          index space, which is the maximum number of array dimensions in IDL:
; 
;            {I:-2, J:3, K:13, L:7, M:1567, N:-2, O:42, P:117}
; 
;          Which is equivalent to:
;	 	
;            [-2,3,13,7,1567,-2,42,117]
; 
;          in standard IDL array subset notation.  Negative intergers are 
;          interpreted to indicate offsets from the end of the index range.
;          Where -1 is the last legal index value.
; 
;          To indicate that an index should be allowed to vary over it's entire
;          range, use the string '*' for the field value.  See the examples 
;          below for the use of '*'.
;	
;          Any field not specified is assumed to have the value '*'.  Thus the
;          following two calls produce identical outputs:
;
;             das2c_data(var, {I:'*', J:'*', K:'*'})
;             das2c_data(var)
;
;          Any fields in the slice structure that apply to dimensions higher
;          than the RANK of the dataset are ignored. (see DAS2C_DSET.RANK)
;
;          Currently only integers (both positive and negative) and the string
;          '*' are understood as slice field values.  Arrays and ranges are not
;          currently supported, though such support could be added if desired.
;         
;
; OUTPUT:
;          An array of values.  The IDL data type of the array is the same
;          as the DAS2C_VAR.TYPE field.
;
; EXAMPLES:
;  Get all time and frequency center coordinates from a dataset regardless of 
;  its RANK and iterate over all coordinates.  This opperation is common when
;  generating spectrograms.
;
;    v_time  = das2c_vars( das2c_pdims(ds, 'time'),      'center' )
;    v_freq  = das2c_vars( das2c_pdims(ds, 'frequency'), 'center' )
;    v_amp   = das2c_vars( das2c_pdims(ds, 'electric'),  'center' )
;
;    a_time  = das2c_data(v_time)
;    a_freq  = das2c_data(v_time)
;    a_amp   = das2c_data(v_time)
;
;    a_time  = reform(a_time, n_elements(a_time) )
;    a_freq  = reform(a_freq, n_elements(a_freq) )
;    a_amp   = reform(a_amp,  n_elements(a_amp)  )
;
;    for I=0,n_elements(a_time)-1 do begin
;      ; some plotting/binning code here
;    endfor
;
;  So long as the dataset has the indicated physical dimensions, this code 
;  works regardless of the internal storage mechanisims.
;
;  Get a all unique center time values for a rank 2 dataset where time is not a
;  function of the first index.
;
;    pd_time = das2c_pdims(ds, 'time')
;    v_time = das2c_vars(pd_time, 'center')
;    a_time = das2c_data(vTime, {I:0, J:'*'})
;
;  Get all unique frequency values for a rank
;
; MODIFICATION HISTORY:
;  In progress
;-
*/
static IDL_VPTR das2c_api_data(int argc, IDL_VPTR* argv)
{	
	
	/* Get the variable or quit */
	int     iQuery = -1;
	DasDs*  pvDs   = NULL;
	DasDim* pvDim  = NULL;
	DasVar* pvVar  = NULL;
	pvVar = das2c_arg_to_var(argc, argv, 0, &iQuery, NULL, &pvDs, &pvDim);
	
	/* Safety cast to const usage */
	const DasDs* pDs = (const DasDs*)pvDs;
	const DasVar* pVar = (const DasVar*)pvVar;
	
	ptrdiff_t aDsShape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	int r, nDsRank = DasDs_shape(pDs, aDsShape);
	
	/* Provide the range of values requested from the variable.  If no range
	  is specified then default to the overall datasets range. */	
	ptrdiff_t aMin[IDL_MAX_ARRAY_DIM] = {0};
	ptrdiff_t aMax[IDL_MAX_ARRAY_DIM] = {0};

	for(r = 0; r < nDsRank; ++r){
		if(aDsShape[r] > 0)
			aMax[r] = aDsShape[r];
		else
			aMax[r] = 1;
	}
	
	/* Trim to the requested shape if desired */
	IDL_VPTR pStruct = NULL;
	if(argc > 1){
		pStruct = argv[1];
		if(pStruct->type != IDL_TYP_STRUCT)
			das2c_IdlMsgExit("Argument %d is not a structure", 2);
		
		/* Ducktyping: Any field name 'i or I' is the first range, and so on.
		 * Stuff we don't understand is ignored */
		for(r = 0; r < nDsRank; ++r)
			_das2c_data_setrng((const ptrdiff_t*)aDsShape, aMin, aMax, r, pStruct);
	}
	
	DasAry* pAry = DasVar_subset(pVar, nDsRank, aMin, aMax);
	
	if((pAry == NULL)||(DasAry_size(pAry) == 0)){
		return IDL_GettmpNULL();  /* no data in range */
	}
	
	/* The output IDL array will have the transpose of the shape from the output
	   of the _subset call */
	ptrdiff_t aAryShape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	int nAryRank = DasAry_shape(pAry, aAryShape);
	IDL_MEMINT dim[IDL_MAX_ARRAY_DIM];
	
	for(r = 0; r < nAryRank; ++r)
		dim[r] = aAryShape[(nAryRank - 1) - r];
	
	
	/* The returned array may already be a copy, if so don't allocate it's
	   memory again */
	size_t uOffset = 0;
	size_t uVals = 0;
	size_t uValSz = DasAry_valSize(pAry);
	byte* pBuf = NULL;
	byte* pSrc = NULL;
	char* pDest = NULL;
		
	IDL_VPTR pRet = NULL;
	
	if(DasAry_ownsElements(pAry)){
		pBuf = DasAry_disownElements(pAry, &uVals, &uOffset);
		pSrc = pBuf + uOffset;
		
		/* Since I know the array is not empty and I know it owned it's elements,
		   pBuf *should* be non-null.  In the rare case it's not, exit with 
			an error */
		if(pBuf == NULL){
			dec_DasAry(pAry);
			das2c_IdlMsgExit("Unexpected behavior from das2C,DasAry_disownElemens()", 2);
		}
		
		/* Start of vals = start of buffer, give buffer to IDL without a copy */
		if(uOffset == 0){
			pRet = IDL_ImportArray(
				nAryRank, 
				dim,
				das2c_vtype_2_idlcode(DasAry_valType(pAry)),
				pBuf,
				_das2c_data_free,
				DasAry_valType(pAry) == vtTime ? DAS_TIME_pdef : NULL
			);
			
			dec_DasAry(pAry);  /* Done with the array */
			return pRet;       /* and we're outta here */
		}
		
		/* Start of vals != start of buffer, IDL_ImportArray() won't work. */
		/* Fall through to the copy op below, but remember to free the buf */
	}
	else{
		/* Array doesn't own the elements, copy them out */
		pSrc = (byte*)DasAry_getIn(pAry, DasAry_valType(pAry), DIM0, &uVals);
	}
	
	/* Copy the data */
	if(DasAry_valType(pAry) == vtTime){
		pDest = IDL_MakeTempStruct(
			DAS_TIME_pdef,
			nAryRank,
			dim,
			&pRet,
			TRUE
		);
	}
	else{
		pDest = IDL_MakeTempArray(
			das2c_vtype_2_idlcode(DasAry_valType(pAry)),
			nAryRank,
			dim,
			IDL_ARR_INI_NOP,
			&pRet
		);
	}
	
	memcpy(pDest, pSrc, uVals * uValSz);
	
	dec_DasAry(pAry);  /* Done with the array */
	
	if(pBuf!=NULL) 
		free(pBuf);  /* we took the memory but couldn't give it to IDL */
		
	return pRet;
}

