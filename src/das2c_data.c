/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

static IDL_STRUCT_TAG_DEF DAS_TIME_tags[] = {
   {"YEAR",   NULL,  (void*)IDL_TYP_LONG},
	{"MONTH",  NULL,  (void*)IDL_TYP_LONG},
	{"MDAY",   NULL,  (void*)IDL_TYP_LONG},
	{"YDAY",   NULL,  (void*)IDL_TYP_LONG},
	{"HOUR",   NULL,  (void*)IDL_TYP_LONG},
	{"MINUTE", NULL,  (void*)IDL_TYP_LONG},
	{"SECOND", NULL,  (void*)IDL_TYP_DOUBLE},
	{0}
};

/* DAS2C_TIME_data struct already defined. It is just the das_time from das2C.
	The tags above supply the IDL definition. */
#define DAS_TIME_data das_time

static IDL_StructDefPtr DAS_TIME_pdef;

static void define_DAS_TIME()
{
	DAS_TIME_pdef = IDL_MakeStruct("DAS_TIME", DAS_TIME_tags);
}

int das2c_vtype_2_idlcode(das_val_type vt)
{
	switch(vt){
	case vtUnknown: return IDL_TYP_BYTE;  /* Must state length somehow */
	case vtByte:    return IDL_TYP_BYTE;
	case vtUShort:  return IDL_TYP_UINT;
	case vtShort:   return IDL_TYP_INT;
	case vtInt:     return IDL_TYP_LONG;
	case vtLong:    return IDL_TYP_LONG64;
	case vtFloat:   return IDL_TYP_FLOAT;
	case vtDouble:  return IDL_TYP_DOUBLE;
	case vtTime:    return IDL_TYP_STRUCT;
	case vtText:    return IDL_TYP_STRING;
	default: return IDL_TYP_UNDEF;
	}	
}

/* ************************************************************************* */
/* Helper, a memset that handles multi-byte items, from das2C */
               
/* Use memcpy because the amount of data written in each call goes up
 * exponentially and memcpy is freaking fast, much faster than a linear
 * write loop for large arrays.
 */
byte* das2c_memset(byte* pDest, const byte* pSrc, size_t uElemSz, size_t uCount)
{
	if(uCount == 0) return pDest;  /* Successfully did nothing */
	if(uElemSz == 0) das2c_IdlMsgExit("Invalid element size");
	if(pDest == NULL) das2c_IdlMsgExit("Invalid destination");
	if(pDest == NULL) das2c_IdlMsgExit("Invalid source");
	
	size_t uDone = 0, uWrite = 0;		
	
	memcpy(pDest, pSrc, uElemSz);
	uDone = 1;
	
	while(uDone < uCount){
		
		if(uDone > (uCount - uDone))  
			uWrite = uCount - uDone;
		else
			uWrite = uDone;	
		
		/* write from ourselves so that the amount of data written each time 
		   goes as the square of the number of loops */
		memcpy(pDest + uDone*uElemSz, pDest, uElemSz*uWrite);
		
		uDone += uWrite;
	}
	
	return pDest;	
}
		

/* ************************************************************************* */
/* API Function, careful with changes! */

#define D2C_DATA_MINA 1
#define D2C_DATA_MAXA 2
#define D2C_DATA_FLAG 0

/*
;+
; FUNCTION:
;  das2c_data
;
; PURPOSE:
;  Get data arrays from das2 variables
;
; CALLING SEQUENCE:
;  Result = das2c_data(var)
;  Result = das2c_data(var, slice)
;
; INPUTS:
;  var:  A DAS2C_VAR structure as returned by das2c_vars()
;
; OPTIONAL INPUTS:
;  slice: An anoymous structure providing a sub range in index space.  By 
;         default das2c_data() returns an array that has the same extent in
;         index space as the overall dataset (see DAS2C_DSET.SHAPE).  This
;         makes it easy to plot data as all correlated values, no matter the
;         underlying storage format, appear at the exact same index set.
; 
;         To save output memory, or when working with a subset of the data, a
;         slice structure be provided which has the following fields:
; 
;           I - The location in the left-most (fastest moving) index.
;           J - The location in the next to fastest moving index
; 
;          ... and so on up to the letter 'P'.
; 
;          The following example specifies a single point in an 8 dimensional
;          index space, which is the maximum number of array dimensions in IDL:
; 
;            {I:-2, J:3, K:13, L:7, M:1567, N:-2, O:42, P:117}
; 
;          Which is equivalent to:
;	 	
;            [-2,3,13,7,1567,-2,42,117]
; 
;          in standard IDL array subset notation.  Negative intergers are 
;          interpreted to indicate offsets from the end of the index range.
;          Where -1 is the last legal index value.
; 
;          To indicate that an index should be allowed to vary over it's entire
;          range, use the string '*' for the field value.  See the examples 
;          below for the use of '*'.
;	
;          Any field not specified is assumed to have the value '*'.  Thus the
;          following two calls produce identical outputs:
;
;             das2c_data(var, {I:'*', J:'*', K:'*'})
;             das2c_data(var)
;
;          Any fields in the slice structure that apply to dimensions higher
;          than the RANK of the dataset are ignored. (see DAS2C_DSET.RANK)
;
;          Currently only integers (both positive and negative) and the string
;          '*' are understood as slice field values.  Arrays and ranges are not
;          currently supported, though such support could be added if desired.
;         
;
; OUTPUT:
;          An array of values.  The IDL data type of the array is the same
;          as the DAS2C_VAR.TYPE field.
;
; EXAMPLES:
;  Get all time and frequency center coordinates from a dataset regardless of 
;  its RANK and iterate over all coordinates.  This opperation is common when
;  generating spectrograms.
;
;    v_time  = das2c_vars( das2c_pdims(ds, 'time'),      'center' )
;    v_freq  = das2c_vars( das2c_pdims(ds, 'frequency'), 'center' )
;    v_amp   = das2c_vars( das2c_pdims(ds, 'electric'),  'center' )
;
;    a_time  = das2c_data(v_time)
;    a_freq  = das2c_data(v_time)
;    a_amp   = das2c_data(v_time)
;
;    a_time  = reform(a_time, n_elements(a_time) )
;    a_freq  = reform(a_freq, n_elements(a_freq) )
;    a_amp   = reform(a_amp,  n_elements(a_amp)  )
;
;    for I=0,n_elements(a_time)-1 do begin
;      ; some plotting/binning code here
;    endfor
;
;  So long as the dataset has the indicated physical dimensions, this code 
;  works regardless of the internal storage mechanisims.
;
;  Get a all unique center time values for a rank 2 dataset where time is not a
;  function of the first index.
;
;    pd_time = das2c_pdims(ds, 'time')
;    v_time = das2c_vars(pd_time, 'center')
;    a_time = das2c_data(vTime, {I:0, J:'*'})
;
;  Get all unique frequency values for a rank
;
; MODIFICATION HISTORY:
;  In progress
;-
*/
static IDL_VPTR das2c_api_data(int argc, IDL_VPTR* argv)
{
	/* Simplistic Algorithm:
	
	   1. Get total extent requested
		
		2. Is it Zero items?   -yes-> return null
		       |
		       V
		2. Do I have an array                -no-> make temp array
		       | yes
				 V
		3. Is the extent equal to the array  -no-> make temp arary
		       | yes
				 V
		4. Wrap the array either the permanent or temporary array
	*/
	
	
	/* Get the variable or quit */
	int iQuery       = -1;
	DasDs*  pvDs  = NULL;
	DasDim* pvDim = NULL;
	DasVar* pvVar = NULL;
	pvVar = das2c_arg_to_var(argc, argv, 0, &iQuery, NULL, &pvDs, &pvDim);
	
	/* Safety cast to const usage */
	const DasDs* pDs = (const DasDs*)pvDs;
	/* const DasDim* pDim = (const DasDim*)pvDim; */
	const DasVar* pVar = (const DasVar*)pvVar;
	
	ptrdiff_t aDsShape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	int nDsRank = DasDs_shape(pDs, aDsShape);
	
	/* ptrdiff_t aReqShape[DASIDX_MAX] = DASIDX_INIT_UNUSED; */ /* requested shape */
	/* int nReqRank = -1; */
	
	ptrdiff_t aVarShape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	int nVarRank = DasVar_shape(pVar, aVarShape);
	
	/*if(argc < 2){
		/ * Easy, requested shape is just the ds shape * /
		memcpy(aReqShape, aDsShape, nDsRank*sizeof(ptrdiff_t));
		nReqRank = nDsRank;
	}
	else{*/
	if(argc > 1)
		/* Hard, now we have to parse a slice structure */
		das2c_IdlMsgExit("TODO: Handle slice structures.");
		
	
	/* Grab the array if it exists */
	DasAry* pvAry;
	if( (pvAry = DasVarAry_getArray(pvVar)) == NULL){
		das2c_IdlMsgExit("TODO: Handle virtual variables.");
	}
	
	IDL_VPTR pRet = NULL;
	
	/* low level byte pointer to head */
	size_t uVals = 0;
	size_t uValSz = 0;
	size_t uBytes = 0;
	
	/* Going to copy out data for now.  Can change this if needed. */
	/* Having IDL reach deep into protected buffers seems like a   */
	/* recipe for disaster */
	const byte* pSrc = DasAry_getIn(pvAry, pVar->vt, DIM0, &uVals);
	uValSz = DasAry_valSize(pvAry);
	uBytes = uVals * uValSz;
	
	/* just quick and dirty for today */
	
	IDL_MEMINT dim[IDL_MAX_ARRAY_DIM];
	
	size_t u;
	for(u = 0; u < nDsRank; ++u)
		dim[u] = aDsShape[(nDsRank - 1) - u];
	
	char* pDest = IDL_MakeTempArray(
		das2c_vtype_2_idlcode(pVar->vt),
		nDsRank,
		dim,
		IDL_ARR_INI_NOP,
		&pRet
	);
	
	/* Staying with quick and dirty.  Here's the memcopys, thinking
	 * in C array layout...
	 *
	 * nReqRank == nVarRank -> nothing to do (for now)
	 * nReqRank > nVarRank
	 *
	 * if aVarShape [-3, N] repeated mem copy in a loop I times
	 * if aVarShape [N, -3] repeated mem set in a loop J times
	*/ 
	
	size_t I = 0;
	size_t uFastestBytes = 0;
	
	if(nDsRank == nVarRank){
		memcpy(pDest, pSrc, uBytes);
	}
	else{
		if(nDsRank != 2) das2c_IdlMsgExit("Logic error 1 in das2c_data()");
		
		if(aVarShape[0] == DASIDX_UNUSED){
			
			if(aVarShape[1] != aDsShape[1]) das2c_IdlMsgExit("Logic error 2 in das2c_data()");
			
			/* for each I, copy a single run of J values */
			for(I = 0; I < aDsShape[0]; ++I)
				memcpy(pDest + (I*uBytes), pSrc, uBytes);
		}
		else{
			if(aVarShape[1] == DASIDX_UNUSED){
				
				if(aVarShape[0] != aDsShape[0]) das2c_IdlMsgExit("Logic error 3 in das2c_data()");
				
				uFastestBytes = aDsShape[1] * uValSz;
				
				/* for each I, fill with a single I value J times */
				for(I = 0; I < aDsShape[0]; ++I)					
					das2c_memset(
						(byte*)(pDest + (I*uFastestBytes)), pSrc + I*uValSz, uValSz, aDsShape[1]
					);
				
			}
			else{
				das2c_IdlMsgExit("Logic error 4 in das2c_data()");
			}
		}
	}
		
	return pRet;
}



























