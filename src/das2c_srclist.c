/* Copyright (C) 2023 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

#define LIST_BUF_SZ 65536

/* Like strchr but only looks in first n characters */
static char* das2c_str_n_chr(char* str, size_t n, char tok){
   size_t i = 0;
   while( i < n && (*str != tok)){
      ++i;
      ++str;
   }

   if((i < n )&&(*str == tok))
      return str;
   else
      return NULL;
}

/* ************************************************************************* */
/* DAS2C_SRCENT (Source Entry) structure */

/* IDL defininiton of DAS2C_SRCENT */
static IDL_STRUCT_TAG_DEF DAS2C_SRCENT_tags[] = {
   {"PATH",     0, (void*)IDL_TYP_STRING},
   {"PROVIDES", 0, (void*)IDL_TYP_STRING},
   
   {0}
};

/* Global struct definition pointer */
static IDL_StructDefPtr DAS2C_SRCENT_pdef;

static void define_DAS2C_SRCENT()
{
   DAS2C_SRCENT_pdef = IDL_MakeStruct("DAS2C_SRCENT", DAS2C_SRCENT_tags);
}

/* C structure to use in casts for manipulating IDL struct memory */
typedef struct das2c_srcent_data_s{
   IDL_STRING path;
   IDL_STRING provides;
} DAS2C_SRCENT_data;

/* ************************************************************************* */
/* API Function, careful with changes! */

#define D2C_SRCLIST_MINA 1
#define D2C_SRCLIST_MAXA 1
#define D2C_SRCLIST_FLAG 0

/*
 ;+
 ; FUNCTION:
 ;  das2c_srclist
 ;
 ; PURPOSE:
 ;  List das2 data stream sources on a given server
 ;
 ; CALLING SEQUENCE:
 ;  string_ary = das2c_srclist(server_root)
 ;
 ; INPUTS:
 ;  server_root: The top level service point of a das2 server.  Typically
 ;               this includes the protocol, host name, and a path.  For
 ;               example: "https://juno.physics.uiowa.edu/das/server"
 ;
 ; OUTPUT:
 ;  An array of structures.  Each one represents a data source that can be
 ;  queried by time, and optionally, other parameters.  If there are 
 ;  no datasources on the server (unlikely) an empty array is returned.
 ;  If the given URL is not a das2 server root, or if there are other 
 ;  communication problems, an error is thrown.
 ;
 ; EXAMPLES:
 ;  root = 'https://juno.physics.uiowa.edu/das/server'
 ;  src_ary = das2c_srclist(root)
 ;  print, 'Data sources available from ', root, ' are:'
 ;  foreach src, src_ary  print, "   ", src
 ;  
 ; MODIFICATION HISTORY:
 ; C. Piker, 2023-12-03 - Initial
 ;-
 */

static IDL_VPTR das2c_api_srclist(int argc, IDL_VPTR* argv)
{
   if(argc < 1)
      das2c_IdlMsgExit("Server root URL required.");

   const char* sSrvRoot = IDL_VarGetString(argv[0]);
   char sInitialUrl[128] = {'\0'}; 
   snprintf(sInitialUrl, 127, "%s?server=list", sSrvRoot);

   /* TODO: Allow setting the user agent via a keyword */
   const char* sUserAgent = "das2dlm/" DAS2DLM_S_VER;
   if(argc > 1) sUserAgent = IDL_VarGetString(argv[1]);
      
   float rConSec = DASHTTP_TO_MIN * DASHTTP_TO_MULTI;

   bool bOkay = false;
   DasHttpResp res;     
   
   DasCredMngr* pAuth = g_pDefCred;  /* defined and initialized in das2c.c */

   bOkay = das_http_getBody(sInitialUrl, sUserAgent, pAuth, &res, rConSec);

   char sError[1024] = {'\0'};
   if(!bOkay){
      snprintf(
         sError, 1023, "%d, Could not get body for URL, reason: %s", 
         res.nCode, res.sError
      );
      DasHttpResp_clear(&res);
      IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, sError);
   }

   DasBuf* pBuf = new_DasBuf(LIST_BUF_SZ); // I doubt lists are bigger then 64K, but check

   size_t uRead = 0;
   if(DasHttpResp_useSsl(&res))
      uRead = DasBuf_writeFromSSL(pBuf, res.pSsl, LIST_BUF_SZ - 1);
   else
      uRead = DasBuf_writeFromSock(pBuf, res.nSockFd, LIST_BUF_SZ - 1);

   if(uRead < 2){
      snprintf(sError, 1023, "%s appears to have no data sources", sSrvRoot);
      IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, sError);
   }

   // Determine the number of sources in the list.  Items that end in '/'
   // are directories, not sources, so skip them

   char* pLine = NULL;
   char* pSep = NULL;
   char cLast;
   size_t uLineLen = 0;
   size_t uSources = 0;
   size_t uLastAlphaNum = 0;
   while( 
      ((pLine = (char*)DasBuf_readRec(pBuf, "\n", 1, &uLineLen)) != NULL)
      && (uLineLen > 0)
   ){
      if(pLine[0] == '|') continue;

      if(pLine[uLineLen - 1] == '\n'){
         uLastAlphaNum = uLineLen - 2;
         if(uLineLen < 2) continue;

         if(pLine[uLineLen - 2] == '\r'){
            uLastAlphaNum = uLineLen - 3;
            if(uLineLen < 3) continue;
         }
      }

      cLast = '\0';
      if( (pSep = das2c_str_n_chr(pLine, uLineLen, '|')) != NULL)
         cLast = *(pSep-1);
      else
         cLast = pLine[uLastAlphaNum];

      if(cLast == '/') continue;
      ++uSources;
   }

   // 2nd read.  Make the output array and write data to it.  All
   // IDL structures are automatically arrays, though many of them
   // are only 1-element long, ours is not.
   IDL_MEMINT dims = uSources;

   IDL_VPTR pRet;

   DAS2C_SRCENT_data* pData = (DAS2C_SRCENT_data*) IDL_MakeTempStruct(
      DAS2C_SRCENT_pdef, /* The opaque structure definition */
      1,                 /* Number of dimensions */
      &dims,             /* Size of each dimension (only one in this case) */
      &pRet,             /* The actual structure variable */
      TRUE               /* Zero out the array */
   );

   /* Rewind the buffer, and loop again */
   DasBuf_setReadOffset(pBuf, 0);

   uLineLen = 0;
   size_t u = 0;
   while( 
      ((pLine = (char*)DasBuf_readRec(pBuf, "\n", 1, &uLineLen)) != NULL)
      && (uLineLen > 0) && (u < uSources)
   ){
      if(pLine[0] == '|') continue;

      // Insert a null at the end of the string replacing the line terminator
      pLine[uLineLen - 1] = '\0';
      --uLineLen;
      if(uLineLen == 0) continue;

      // Deal with DOS line endings
      if(pLine[uLineLen-1] == '\r'){
         pLine[uLineLen-1] = '\0';
         --uLineLen;
         if(uLineLen == 0) continue;         
      }

      cLast = '\0';
      if((pSep = das2c_str_n_chr(pLine, uLineLen, '|')) != NULL) {
         cLast = *(pSep-1);
         *pSep = '\0';  // replace separator with a null
      }
      else
         cLast = pLine[uLineLen - 1];

      if(cLast == '/') continue;

      if(pSep && (*(pSep+1) != '\0'))
         IDL_StrStore(&(pData->provides), pSep+1);
      
      IDL_StrStore(&(pData->path), pLine);
      ++u;

      ++pData;
   }

   return pRet;
}
