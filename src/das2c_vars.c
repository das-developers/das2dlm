/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

/* Output structure definition.  Since only variables from the same dataset
   are used together we can trim the shape array, unfortunatly IDL DLMs have
	can't access LIST() or MAP() so have to repeate var definitions for every
	dataset size.  */
static IDL_STRUCT_TAG_DEF _das2c_var_tags_1[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},    /* ID items */
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},

	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},  /* info */
	{"SHAPE",   g_aShape1, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},

	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},  /* contents */
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_2[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape2, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_3[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape3, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_4[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape4, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_5[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape5, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_6[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape6, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_7[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape7, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_8[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape8, (void*)IDL_TYP_LONG64},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};

typedef struct _das2c_var_sum_1{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[1];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_1;

typedef struct _das2c_var_sum_2{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[2];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_2;

typedef struct _das2c_var_sum_3{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[3];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_3;

typedef struct _das2c_var_sum_4{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[4];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_4;

typedef struct _das2c_var_sum_5{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[5];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_5;

typedef struct _das2c_var_sum_6{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[6];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_6;

typedef struct _das2c_var_sum_7{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[7];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_7;

typedef struct _das2c_var_sum_8{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_LONG64 shape[8];
	IDL_STRING type;
	IDL_LONG64 n_vals;
} das2c_VarSummary_8;


static IDL_StructDefPtr g_das2c_pVarSumDef_1;
static IDL_StructDefPtr g_das2c_pVarSumDef_2;
static IDL_StructDefPtr g_das2c_pVarSumDef_3;
static IDL_StructDefPtr g_das2c_pVarSumDef_4;
static IDL_StructDefPtr g_das2c_pVarSumDef_5;
static IDL_StructDefPtr g_das2c_pVarSumDef_6;
static IDL_StructDefPtr g_das2c_pVarSumDef_7;
static IDL_StructDefPtr g_das2c_pVarSumDef_8;

static void DAS2C_VAR_def()
{
	g_das2c_pVarSumDef_1 = IDL_MakeStruct("DAS2C_VAR_1", _das2c_var_tags_1);
	g_das2c_pVarSumDef_2 = IDL_MakeStruct("DAS2C_VAR_2", _das2c_var_tags_2);
	g_das2c_pVarSumDef_3 = IDL_MakeStruct("DAS2C_VAR_3", _das2c_var_tags_3);
	g_das2c_pVarSumDef_4 = IDL_MakeStruct("DAS2C_VAR_4", _das2c_var_tags_4);
	g_das2c_pVarSumDef_5 = IDL_MakeStruct("DAS2C_VAR_5", _das2c_var_tags_5);
	g_das2c_pVarSumDef_6 = IDL_MakeStruct("DAS2C_VAR_6", _das2c_var_tags_6);
	g_das2c_pVarSumDef_7 = IDL_MakeStruct("DAS2C_VAR_7", _das2c_var_tags_7);
	g_das2c_pVarSumDef_8 = IDL_MakeStruct("DAS2C_VAR_8", _das2c_var_tags_8);
}

static IDL_StructDefPtr das2c_get_varsum_def(int nRank)
{
	switch(nRank){
	case 1: return g_das2c_pVarSumDef_1;
	case 2: return g_das2c_pVarSumDef_2;
	case 3: return g_das2c_pVarSumDef_3;
	case 4: return g_das2c_pVarSumDef_4;
	case 5: return g_das2c_pVarSumDef_5;
	case 6: return g_das2c_pVarSumDef_6;
	case 7: return g_das2c_pVarSumDef_7;
	case 8: return g_das2c_pVarSumDef_8;
	default:return NULL;
	}
}

/* ************************************************************************* */
/* Downstream arg helpers */

/* returns either a var id, or -1 and a var role string */
static int das2c_args_var_id(
	int argc, IDL_VPTR* argv, int iArg, char* sRole, size_t uLen
){
	int iVar= -1;
	const char* sTmp = NULL;
	memset(sRole, 0, uLen);
	
	if(uLen < 2) das2c_IdlMsgExit("uLen too short");
	
	if(argc <= iArg)
		das2c_IdlMsgExit(
			"Variable role was not specified, either a string or an integer "
			"is required for argument number %d", iArg
		);
	
	/* See if this is as string */
	if(argv[iArg]->type == IDL_TYP_STRING){
		sTmp = IDL_VarGetString(argv[iArg]);
		if(*sTmp == '\0') das2c_IdlMsgExit("Role string is empty");
		
		strncpy(sRole, sTmp, uLen-1);
		return iVar;
	}
	
	IDL_VPTR pTmpVar = IDL_BasicTypeConversion(1, argv + iArg, IDL_TYP_LONG);
	
	iVar = pTmpVar->value.l;
	IDL_DELTMP(pTmpVar);
	if(iVar < 0) das2c_IdlMsgExit("Invalid variable index %d", iVar);
		
	return iVar;
}

/* if var role or id is valid, set the missing item and return the var ptr */
static const DasVar* das2c_check_var_id(
	const DasIdlDbEnt* pEnt, int iDs, const DasDim* pDim,
	int* iVar, char* sRole, size_t uLen  /* one of these is valid */
){
	int i = 0;
	const DasVar* pVar = NULL;
	
	if((sRole == NULL)||(sRole[0] == '\0')){
		/* Lookup by index and save the name */
		if((*iVar > 0)&&(*iVar < pDim->uVars))
			pVar = pDim->aVars[*iVar];
		else
			das2c_IdlMsgExit(
				"Query result %d, dataset %d, dimension '%s', doesn't have a"
				" variable with index number '%d'", 
				pEnt->nQueryId, iDs, pDim->sId, *iVar
			);
		
		strncpy(sRole, pDim->aRoles[*iVar], uLen);
	}
	else{
		/* Lookup by name and save the index */
		pVar = DasDim_getVar(pDim, sRole);
		if(pVar == NULL)
			das2c_IdlMsgExit(
				"Query result %d, dataset %d, dimension '%s', doesn't have a"
				" variable for role '%s'", pEnt->nQueryId, iDs, pDim->sId,
				sRole
			);
		
		for(i = 0; i < pDim->uVars; ++i){
			if(pDim->aVars[i] == pVar) *iVar = i;
		}
		if(*iVar == -1) das2c_IdlMsgExit("Logic error1 das2c_check_var_id");
	}
	
	return pVar;
}

/* ************************************************************************* */
/* API Function, careful with changes! */

#define D2C_VARS_MINA 1
#define D2C_VARS_MAXA 2
#define D2C_VARS_FLAG 0

/*
;+
; FUNCTION:
;  das2c_vars
;
; PURPOSE:
;  List the variables present in a physical dimension, in a das2 dataset.
;
; CALLING SEQUENCE:
;  Result = das2c_vars(pdim)
;  Result = das2c_vars(pdim, var)
;
; INPUTS:
;  pdim: A DAS2C_PDIM structure as returned by das2c_pdims().
;
; OPTIONAL INPUTS:
;  var:      A variables role name (string). This argument is only needed
;            if information on a single variable is desired.
;
;            Variable role names are standardized.  The most common one is
;            'center' which represents the central point of a measurement
;            in a particular physical dimension.  The full set is:
;
;            'center', 'offest', 'min', 'max', 'width', 'mean', 'median',
;            'mode', 'reference', 'offset', 'max_error', 'min_error',
;            'uncertainty',  'std_dev', 'point_spread', 'weight'
;
; OUTPUT:
;  This function returns an array of structures providing an overview of each
;  variable in this physical dimension.  Output structures have the following
;  fields:
;
;    QUERY (Long)       The query ID of this dataset, starts from 1
;
;    DSET  (Long)       The ID number of this dataset, starts from 0
;
;    PDIM  (String)     The name of this physical dimension, ex: 'time'
;
;    VAR   (String)     The role name for this variable.  These are standardize.
;                       See the optional inputs section above for details.
;
;    UNITS (String)     The units for values from this variable.  The default
;                       units format follows the fortran convention of using
;                       two astricks (**) to indicate exponentiation.
;
;    SHAPE (Long64 Arr) This array is DAS2C_DSET.RANK elements long. It provides
;                       information on the internal storage of the variable that
;                       is of use when calling das2c_data().
;                      
;                       While all variables have the same shape in index space
;                       as the overall dataset, they may be backed by arrays 
;                       that are actually smaller than the overall dataset shape
;                       would indicate.  Also, some variables may generate data 
;                       from a sequence calculation and thus do not have a 
;                       backing array at all.  Each element of SHAPE has one of
;                       the following values:
;                      
;                         N:  An integer >= 0 means that this variable produces
;                             potentially unique values in this index when 
;                             calling das2c_data().  This integer will be the
;                             same as the corresponding value from 
;                             DAS2C_DSET.SHAPE.
;
;                         -3: The variable is degenerate in this index, so
;                             any integer used for this index will not affect
;                             the output of a das2c_data() call.  This is 
;                             common for variables in coordinate dimensions.
;                             (see DAS2C_PDIM.USE)
;                       
;                         -1: The variable has no internal storage at all 
;                             corresponding to this index.  It is a sequence.
;                             The output from a das2c_data() call is calculated
;                             based on the index values supplied, or indicated,
;                             by the caller.
;
;    'TYPE':   String   The IDL datatype of the output of das2c_data() calls
;                       for this variable.
;
;    'N_VALS': Long64   If this variable is directly backed by an array this
;                       is the total number of real storage locations in that
;                       array.
;
; If a variable is requested for a role that doesn't exist in the given physical
; dimension, !NULL is returned.
;
; EXAMPLES:
;  List summary of all variable roles for the 'time' dimension in dataset 0 of
;  query result 27
;    query = das2c_query(27)
;    ds = das2c_datasets(0)
;    pd_time = das2c_pdims(ds, 'time')
;
;    das2c_vars(pd_time)
;
;  List summary information of the 'center' variable for the 'time' dimension
;  above:
;    das2c_vars(pd_time, 'center')
;
; MODIFICATION HISTORY:
;  Written by: Chris Piker, 2020-03-13
;-
*/
static IDL_VPTR das2c_api_vars(int argc, IDL_VPTR* argv)
{
	/* Get/check Query ID */
	int iQueryId = das2c_args_query_id(argc, argv, 0);
	const DasIdlDbEnt* pEnt = das2c_check_query_id(iQueryId);
	
	/* Get/check dataset ID */
	int iDs = das2c_args_ds_id(argc, argv, 1);
	const DasDs* pDs = das2c_check_ds_id(pEnt, iDs);
	int nDsRank = DasDs_rank(pDs);
	
	/* Get/check physical dimension ID/Name */
	char sDim[128] = {'\0'};
	int iDim = das2c_args_dim_id(argc, argv, 2, sDim, 127);
	const DasDim* pDim = das2c_check_dim_id(pEnt, iDs, &iDim, sDim, 127);
	
	const DasVar* pTheVar = NULL;
	char sRole[64] = {'\0'};
	int iVar = -1;
	
	if(argc > 3){
		iVar = das2c_args_var_id(argc, argv, 3, sRole, 63);
		pTheVar = das2c_check_var_id(pEnt, iDs, pDim, &iVar, sRole, 63);
	}
		
	/* See if they want just one var or many */
	IDL_MEMINT dims = 1;
	if(pTheVar == NULL) dims = pDim->uVars;
	
	IDL_VPTR pRet;  /* the to-be-returned structure */
	
	/* AGGG! Lack of access to IDL_TYP_OBJREF rases it's ugly head again!  */
	/* We need different code paths because there are 8 different possible */
	/* casts for the data pointer!!!! */

	/* Returns pRet->value.s.arr.data */
	void* pData = IDL_MakeTempStruct(
		das2c_get_varsum_def(nDsRank),  /* The opaque structure definition */
		1,                   /* Number of dimesions */
		&dims,               /* Size of each dimension, (only one dimension) */
		&pRet,               /* The actual structure variable */
		TRUE                 /* Zero out the array */
	);
	
	das2c_VarSummary_1* pData1 = NULL;
	das2c_VarSummary_2* pData2 = NULL;
	das2c_VarSummary_3* pData3 = NULL;
	das2c_VarSummary_4* pData4 = NULL;
	das2c_VarSummary_5* pData5 = NULL;
	das2c_VarSummary_6* pData6 = NULL;
	das2c_VarSummary_7* pData7 = NULL;
	das2c_VarSummary_8* pData8 = NULL;
	switch(nDsRank){
	case 1: pData1 = (das2c_VarSummary_1*)pData; break;
	case 2: pData2 = (das2c_VarSummary_2*)pData; break;
	case 3: pData3 = (das2c_VarSummary_3*)pData; break;
	case 4: pData4 = (das2c_VarSummary_4*)pData; break;
	case 5: pData5 = (das2c_VarSummary_5*)pData; break;
	case 6: pData6 = (das2c_VarSummary_6*)pData; break;
	case 7: pData7 = (das2c_VarSummary_7*)pData; break;
	case 8: pData8 = (das2c_VarSummary_8*)pData; break;
	default: das2c_IdlMsgExit("Logic error2, das2c_vars");  break;
	}
	
	const DasVar* pVar = NULL;
	const DasAry* pAry = NULL;
	size_t u = 0, r = 0;
	/*int nRank = -1; */
	ptrdiff_t shape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	
	for(u = 0; u < pDim->uVars; ++u){
		pVar = pDim->aVars[u];
		if(pVar == NULL) das2c_IdlMsgExit("Logic error3, das2c_vars");
		
		/* If we have a single role to report and this ain't it, continue */
		if((pTheVar != NULL)&&(pVar != pTheVar)) continue;
		
		DasVar_shape(pVar, shape);
		
		switch(nDsRank){
		
		case 1:
		pData1->id = u;
		pData1->size = 0;	
		IDL_StrStore(&(pData1->name), pDim->sId);
		IDL_StrStore(&(pData1->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData1->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData1->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData1->size += DasAry_size(pAry);
		++pData1;
		break;
		
		case 2:
		pData2->id = u;
		pData2->size = 0;	
		IDL_StrStore(&(pData2->name), pDim->sId);
		IDL_StrStore(&(pData2->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData2->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData2->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData2->size += DasAry_size(pAry);
		++pData2;
		break;

		case 3:
		pData3->id = u;
		pData3->size = 0;	
		IDL_StrStore(&(pData3->name), pDim->sId);
		IDL_StrStore(&(pData3->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData3->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData3->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData3->size += DasAry_size(pAry);
		++pData3;
		break;
		
		case 4:
		pData4->id = u;
		pData4->size = 0;	
		IDL_StrStore(&(pData4->name), pDim->sId);
		IDL_StrStore(&(pData4->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData4->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData4->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData4->size += DasAry_size(pAry);
		++pData4;
		break;

		case 5:
		pData5->id = u;
		pData5->size = 0;	
		IDL_StrStore(&(pData5->name), pDim->sId);
		IDL_StrStore(&(pData5->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData5->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData5->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData5->size += DasAry_size(pAry);
		++pData5;
		break;

		case 6:
		pData6->id = u;
		pData6->size = 0;	
		IDL_StrStore(&(pData6->name), pDim->sId);
		IDL_StrStore(&(pData6->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData6->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData6->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData6->size += DasAry_size(pAry);
		++pData6;
		break;

		case 7:
		pData7->id = u;
		pData7->size = 0;	
		IDL_StrStore(&(pData7->name), pDim->sId);
		IDL_StrStore(&(pData7->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData7->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData7->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData7->size += DasAry_size(pAry);
		++pData7;
		break;

		case 8:
		pData8->id = u;
		pData8->size = 0;	
		IDL_StrStore(&(pData8->name), pDim->sId);
		IDL_StrStore(&(pData8->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData8->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData8->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData8->size += DasAry_size(pAry);
		++pData8;
		break;
		
		default: das2c_IdlMsgExit("Logic error4, das2c_vars");
		}
		
		if(pTheVar != NULL) break;
	}
	
	return pRet;
}
