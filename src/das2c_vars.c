/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

/* Output structure definition.  Since only variables from the same dataset
   are used together we can trim the shape array, unfortunatly IDL DLMs have
	can't access LIST() or MAP() so have to repeate var definitions for every
	dataset size.  */
static IDL_STRUCT_TAG_DEF _das2c_var_tags_1[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape1, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_2[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape2, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_3[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape3, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_4[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape4, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_5[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape5, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_6[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape6, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_7[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape7, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF _das2c_var_tags_8[] = {
	{"ID",      NULL,     (void*)IDL_TYP_LONG},
	{"NAME",    NULL,     (void*)IDL_TYP_STRING},
	{"ROLE",    NULL,     (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,     (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape8, (void*)IDL_TYP_LONG64},
	{"SIZE",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};

typedef struct _das2c_var_sum_1{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[1];
	IDL_LONG64 size;
} das2c_VarSummary_1;

typedef struct _das2c_var_sum_2{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[2];
	IDL_LONG64 size;
} das2c_VarSummary_2;

typedef struct _das2c_var_sum_3{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[3];
	IDL_LONG64 size;
} das2c_VarSummary_3;

typedef struct _das2c_var_sum_4{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[4];
	IDL_LONG64 size;
} das2c_VarSummary_4;

typedef struct _das2c_var_sum_5{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[5];
	IDL_LONG64 size;
} das2c_VarSummary_5;

typedef struct _das2c_var_sum_6{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[6];
	IDL_LONG64 size;
} das2c_VarSummary_6;

typedef struct _das2c_var_sum_7{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[7];
	IDL_LONG64 size;
} das2c_VarSummary_7;

typedef struct _das2c_var_sum_8{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[8];
	IDL_LONG64 size;
} das2c_VarSummary_8;

static IDL_StructDefPtr g_das2c_pVarSumDef_1;
static IDL_StructDefPtr g_das2c_pVarSumDef_2;
static IDL_StructDefPtr g_das2c_pVarSumDef_3;
static IDL_StructDefPtr g_das2c_pVarSumDef_4;
static IDL_StructDefPtr g_das2c_pVarSumDef_5;
static IDL_StructDefPtr g_das2c_pVarSumDef_6;
static IDL_StructDefPtr g_das2c_pVarSumDef_7;
static IDL_StructDefPtr g_das2c_pVarSumDef_8;

static void DAS2C_VAR_def()
{
	g_das2c_pVarSumDef_1 = IDL_MakeStruct("DAS2C_VAR_1", _das2c_var_tags_1);
	g_das2c_pVarSumDef_2 = IDL_MakeStruct("DAS2C_VAR_2", _das2c_var_tags_2);
	g_das2c_pVarSumDef_3 = IDL_MakeStruct("DAS2C_VAR_3", _das2c_var_tags_3);
	g_das2c_pVarSumDef_4 = IDL_MakeStruct("DAS2C_VAR_4", _das2c_var_tags_4);
	g_das2c_pVarSumDef_5 = IDL_MakeStruct("DAS2C_VAR_5", _das2c_var_tags_5);
	g_das2c_pVarSumDef_6 = IDL_MakeStruct("DAS2C_VAR_6", _das2c_var_tags_6);
	g_das2c_pVarSumDef_7 = IDL_MakeStruct("DAS2C_VAR_7", _das2c_var_tags_7);
	g_das2c_pVarSumDef_8 = IDL_MakeStruct("DAS2C_VAR_8", _das2c_var_tags_8);
}

static IDL_StructDefPtr das2c_get_varsum_def(int nRank)
{
	switch(nRank){
	case 1: return g_das2c_pVarSumDef_1;
	case 2: return g_das2c_pVarSumDef_2;
	case 3: return g_das2c_pVarSumDef_3;
	case 4: return g_das2c_pVarSumDef_4;
	case 5: return g_das2c_pVarSumDef_5;
	case 6: return g_das2c_pVarSumDef_6;
	case 7: return g_das2c_pVarSumDef_7;
	case 8: return g_das2c_pVarSumDef_8;
	default:return NULL;
	}
}

/* ************************************************************************* */
/* Downstream arg helpers */

/* returns either a var id, or -1 and a var role string */
static int das2c_args_var_id(
	int argc, IDL_VPTR* argv, int iArg, char* sRole, size_t uLen
){
	int iVar= -1;
	const char* sTmp = NULL;
	memset(sRole, 0, uLen);
	
	if(uLen < 2) das2c_IdlMsgExit("uLen too short");
	
	if(argc <= iArg)
		das2c_IdlMsgExit(
			"Variable role was not specified, either a string or an integer "
			"is required for argument number %d", iArg
		);
	
	/* See if this is as string */
	if(argv[iArg]->type == IDL_TYP_STRING){
		sTmp = IDL_VarGetString(argv[iArg]);
		if(*sTmp == '\0') das2c_IdlMsgExit("Role string is empty");
		
		strncpy(sRole, sTmp, uLen-1);
		return iVar;
	}
	
	IDL_VPTR pTmpVar = IDL_BasicTypeConversion(1, argv + iArg, IDL_TYP_LONG);
	
	iVar = pTmpVar->value.l;
	IDL_DELTMP(pTmpVar);
	if(iVar < 0) das2c_IdlMsgExit("Invalid variable index %d", iVar);
		
	return iVar;
}

/* if var role or id is valid, set the missing item and return the var ptr */
static const DasVar* das2c_check_var_id(
	const DasIdlDbEnt* pEnt, int iDs, const DasDim* pDim,
	int* iVar, char* sRole, size_t uLen  /* one of these is valid */
){
	int i = 0;
	const DasVar* pVar = NULL;
	
	if((sRole == NULL)||(sRole[0] == '\0')){
		/* Lookup by index and save the name */
		if((*iVar > 0)&&(*iVar < pDim->uVars))
			pVar = pDim->aVars[*iVar];
		else
			das2c_IdlMsgExit(
				"Query result %d, dataset %d, dimension '%s', doesn't have a"
				" variable with index number '%d'", 
				pEnt->nQueryId, iDs, pDim->sId, *iVar
			);
		
		strncpy(sRole, pDim->aRoles[*iVar], uLen);
	}
	else{
		/* Lookup by name and save the index */
		pVar = DasDim_getVar(pDim, sRole);
		if(pVar == NULL)
			das2c_IdlMsgExit(
				"Query result %d, dataset %d, dimension '%s', doesn't have a"
				" variable for role '%s'", pEnt->nQueryId, iDs, pDim->sId,
				sRole
			);
		
		for(i = 0; i < pDim->uVars; ++i){
			if(pDim->aVars[i] == pVar) *iVar = i;
		}
		if(*iVar == -1) das2c_IdlMsgExit("Logic error1 das2c_check_var_id");
	}
	
	return pVar;
}

/* ************************************************************************* */
/* API Function, careful with changes! */

#define D2C_VARS_MINA 3
#define D2C_VARS_MAXA 4
#define D2C_VARS_FLAG 0

/*
;+
; FUNCTION:
;  das2c_vars
;
; PURPOSE:
;  List the variables present in a physical dimension, in a das2 dataset.
;
; CALLING SEQUENCE:
;  Result = das2c_vars(query_id, ds_index, pdim, var)
;
; INPUTS:
;  query_id: The identification integer for the stored query result as
;            returned by das2c_readhttp() or das2c_queries.
;
;  ds_index: The dataset index, often 0.  See das2c_datasets() for details.
;
;  pdim:     Either the physical dimension index (long), or the dimension's
;            name (string).  For more infor see das2c_physdims().
;
; OPTIONAL INPUTS:
;  var:      Either the role name (string) or the var index (long).  This
;            argument is only required if summary information on a single 
;            variable is desired.
;
;            Variable role names are standardized.  The most common one is
;            'center' which represents the central point of a measurement
;            in a particular physical dimension.  The full set is:
;
;            'center', 'offest', 'min', 'max', 'width', 'mean', 'median',
;            'mode', 'reference', 'offset', 'max_error', 'min_error',
;            'uncertainty',  'std_dev', 'point_spread', 'weight'
;
; OUTPUT:
;  This function returns an array of structures providing an overview of
;  each stored result.  Output structures have the fields:
;
;    'id':     Long     ; The ID number for this variable.  Usage of
;                       ; role names instead of numbers is recommended.
;	
;    'name':   String   ; The name of the physical dimension for this variable
;
;    'type':   String   ; The IDL datatype of the values in this variable.
;
;    'role':   String   ; The role for this variable, for example 'max_error'
;
;    'units':  String   ; The units for values from this variable.
;
;    'shape':  N Long64 ; The extent of this variable in the dataset indices.
;                       ; Certian flag values have special meanings:
;                       ;
;                       ;   -3 : The variable is degenerate in this index. I.e.
;                       ;        any value used here will not affect the output.
;                       ;
;                       ;   -1 : This is a virtual variable that has no internal
;                       ;        storage but rather generates a value based
;                       ;        on the index provided.  See Das2 Virtual
;                       ;        variables for more information.
;
;
;    'size':   Long64   ; If this variable is directly backed by an array this
;                       ; is the total number of values in that array.  This
;                       ; value is 0 for virtual variables.
;
; TODO:
;  Should this function return !NULL if a requested role doesn't exist in a
;  physical dimension?
;
; EXAMPLES:
;  List summary of all variable roles for the 'time' dimension in dataset 0 of
;  query result 27
;    das2c_vars(27, 0, 'time')
;
;  List summary information of the 'center' variable for 'time' in dataset 0 for
;  query result 27
;    das2c_vars(27, 0, 'time', 'center')
;
;  List summary information for the first variable in the first physical
;  physical dimension of the first datasets, what ever it happens to be.
;    das2c_vars(27, 0, 0, 0)
;
; MODIFICATION HISTORY:
;  Written by: Chris Piker, 2020-03-10
;-
*/
static IDL_VPTR das2c_api_vars(int argc, IDL_VPTR* argv)
{
	/* Get/check Query ID */
	int iQueryId = das2c_args_query_id(argc, argv, 0);
	const DasIdlDbEnt* pEnt = das2c_check_query_id(iQueryId);
	
	/* Get/check dataset ID */
	int iDs = das2c_args_ds_id(argc, argv, 1);
	const DasDs* pDs = das2c_check_ds_id(pEnt, iDs);
	int nDsRank = DasDs_rank(pDs);
	
	/* Get/check physical dimension ID/Name */
	char sDim[128] = {'\0'};
	int iDim = das2c_args_dim_id(argc, argv, 2, sDim, 127);
	const DasDim* pDim = das2c_check_dim_id(pEnt, iDs, &iDim, sDim, 127);
	
	const DasVar* pTheVar = NULL;
	char sRole[64] = {'\0'};
	int iVar = -1;
	
	if(argc > 3){
		iVar = das2c_args_var_id(argc, argv, 3, sRole, 63);
		pTheVar = das2c_check_var_id(pEnt, iDs, pDim, &iVar, sRole, 63);
	}
		
	/* See if they want just one var or many */
	IDL_MEMINT dims = 1;
	if(pTheVar == NULL) dims = pDim->uVars;
	
	IDL_VPTR pRet;  /* the to-be-returned structure */
	
	/* AGGG! Lack of access to IDL_TYP_OBJREF rases it's ugly head again!  */
	/* We need different code paths because there are 8 different possible */
	/* casts for the data pointer!!!! */

	/* Returns pRet->value.s.arr.data */
	void* pData = IDL_MakeTempStruct(
		das2c_get_varsum_def(nDsRank),  /* The opaque structure definition */
		1,                   /* Number of dimesions */
		&dims,               /* Size of each dimension, (only one dimension) */
		&pRet,               /* The actual structure variable */
		TRUE                 /* Zero out the array */
	);
	
	das2c_VarSummary_1* pData1 = NULL;
	das2c_VarSummary_2* pData2 = NULL;
	das2c_VarSummary_3* pData3 = NULL;
	das2c_VarSummary_4* pData4 = NULL;
	das2c_VarSummary_5* pData5 = NULL;
	das2c_VarSummary_6* pData6 = NULL;
	das2c_VarSummary_7* pData7 = NULL;
	das2c_VarSummary_8* pData8 = NULL;
	switch(nDsRank){
	case 1: pData1 = (das2c_VarSummary_1*)pData; break;
	case 2: pData2 = (das2c_VarSummary_2*)pData; break;
	case 3: pData3 = (das2c_VarSummary_3*)pData; break;
	case 4: pData4 = (das2c_VarSummary_4*)pData; break;
	case 5: pData5 = (das2c_VarSummary_5*)pData; break;
	case 6: pData6 = (das2c_VarSummary_6*)pData; break;
	case 7: pData7 = (das2c_VarSummary_7*)pData; break;
	case 8: pData8 = (das2c_VarSummary_8*)pData; break;
	default: das2c_IdlMsgExit("Logic error2, das2c_vars");  break;
	}
	
	const DasVar* pVar = NULL;
	const DasAry* pAry = NULL;
	size_t u = 0, r = 0;
	/*int nRank = -1; */
	ptrdiff_t shape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	
	for(u = 0; u < pDim->uVars; ++u){
		pVar = pDim->aVars[u];
		if(pVar == NULL) das2c_IdlMsgExit("Logic error3, das2c_vars");
		
		/* If we have a single role to report and this ain't it, continue */
		if((pTheVar != NULL)&&(pVar != pTheVar)) continue;
		
		DasVar_shape(pVar, shape);
		
		switch(nDsRank){
		
		case 1:
		pData1->id = u;
		pData1->size = 0;	
		IDL_StrStore(&(pData1->name), pDim->sId);
		IDL_StrStore(&(pData1->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData1->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData1->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData1->size += DasAry_size(pAry);
		++pData1;
		break;
		
		case 2:
		pData2->id = u;
		pData2->size = 0;	
		IDL_StrStore(&(pData2->name), pDim->sId);
		IDL_StrStore(&(pData2->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData2->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData2->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData2->size += DasAry_size(pAry);
		++pData2;
		break;

		case 3:
		pData3->id = u;
		pData3->size = 0;	
		IDL_StrStore(&(pData3->name), pDim->sId);
		IDL_StrStore(&(pData3->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData3->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData3->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData3->size += DasAry_size(pAry);
		++pData3;
		break;
		
		case 4:
		pData4->id = u;
		pData4->size = 0;	
		IDL_StrStore(&(pData4->name), pDim->sId);
		IDL_StrStore(&(pData4->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData4->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData4->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData4->size += DasAry_size(pAry);
		++pData4;
		break;

		case 5:
		pData5->id = u;
		pData5->size = 0;	
		IDL_StrStore(&(pData5->name), pDim->sId);
		IDL_StrStore(&(pData5->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData5->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData5->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData5->size += DasAry_size(pAry);
		++pData5;
		break;

		case 6:
		pData6->id = u;
		pData6->size = 0;	
		IDL_StrStore(&(pData6->name), pDim->sId);
		IDL_StrStore(&(pData6->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData6->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData6->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData6->size += DasAry_size(pAry);
		++pData6;
		break;

		case 7:
		pData7->id = u;
		pData7->size = 0;	
		IDL_StrStore(&(pData7->name), pDim->sId);
		IDL_StrStore(&(pData7->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData7->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData7->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData7->size += DasAry_size(pAry);
		++pData7;
		break;

		case 8:
		pData8->id = u;
		pData8->size = 0;	
		IDL_StrStore(&(pData8->name), pDim->sId);
		IDL_StrStore(&(pData8->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData8->units), Units_toStr(pVar->units));	
		for(r = 0; r < nDsRank; ++r) pData8->shape[(nDsRank - 1) - r] = shape[r];
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData8->size += DasAry_size(pAry);
		++pData8;
		break;
		
		default: das2c_IdlMsgExit("Logic error4, das2c_vars");
		}
		
		if(pTheVar != NULL) break;
	}
	
	return pRet;
}
