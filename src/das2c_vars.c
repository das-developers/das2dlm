/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */

/* Output structure definition */
static IDL_STRUCT_TAG_DEF _das2c_var_tags[] = {
	{"id",      NULL,     (void*)IDL_TYP_LONG},
	{"name",    NULL,     (void*)IDL_TYP_STRING},
	{"role",    NULL,     (void*)IDL_TYP_STRING},
	{"units",   NULL,     (void*)IDL_TYP_STRING},
	{"shape",   g_aShape, (void*)IDL_TYP_LONG64},
	{"size",    NULL,     (void*)IDL_TYP_LONG64},
	{0}
};

typedef struct _das2c_var_sum{
	IDL_LONG   id;
	IDL_STRING name;
	IDL_STRING role;
	IDL_STRING units;
	IDL_LONG64 shape[IDL_MAX_ARRAY_DIM];
	IDL_LONG64 size;
} das2c_VarSummary;

static IDL_StructDefPtr g_das2c_pVarSumDef;

static void DAS2C_VAR_def()
{
	g_das2c_pVarSumDef = IDL_MakeStruct("DAS2C_VAR", _das2c_var_tags);
}

/* ************************************************************************* */
/* Downstream arg helpers */

/* returns either a var id, or -1 and a var role string */
static int das2c_args_var_id(
	int argc, IDL_VPTR* argv, int iArg, char* sRole, size_t uLen
){
	int iVar= -1;
	const char* sTmp = NULL;
	memset(sRole, 0, uLen);
	
	if(uLen < 2) das2c_IdlMsgExit("uLen too short");
	
	if(argc <= iArg)
		das2c_IdlMsgExit(
			"Variable role was not specified, either a string or an integer "
			"is required for argument number %d", iArg
		);
	
	/* See if this is as string */
	if(argv[iArg]->type == IDL_TYP_STRING){
		sTmp = IDL_VarGetString(argv[iArg]);
		if(*sTmp == '\0') das2c_IdlMsgExit("Role string is empty");
		
		strncpy(sRole, sTmp, uLen-1);
		return iVar;
	}
	
	IDL_VPTR pTmpVar = IDL_BasicTypeConversion(1, argv + iArg, IDL_TYP_LONG);
	
	iVar = pTmpVar->value.l;
	IDL_DELTMP(pTmpVar);
	if(iVar < 0) das2c_IdlMsgExit("Invalid variable index %d", iVar);
		
	return iVar;
}

/* if var role or id is valid, set the missing item and return the var ptr */
static const DasVar* das2c_check_var_id(
	const DasIdlDbEnt* pEnt, int iDs, const DasDim* pDim,
	int* iVar, char* sRole, size_t uLen  /* one of these is valid */
){
	int i = 0;
	const DasVar* pVar = NULL;
	
	if((sRole == NULL)||(sRole[0] == '\0')){
		/* Lookup by index and save the name */
		if((*iVar > 0)&&(*iVar < pDim->uVars))
			pVar = pDim->aVars[*iVar];
		else
			das2c_IdlMsgExit(
				"Query result %d, dataset %d, dimension '%s', doesn't have a"
				" variable with index number '%d'", 
				pEnt->nQueryId, iDs, pDim->sId, *iVar
			);
		
		strncpy(sRole, pDim->aRoles[*iVar], uLen);
	}
	else{
		/* Lookup by name and save the index */
		pVar = DasDim_getVar(pDim, sRole);
		if(pVar == NULL)
			das2c_IdlMsgExit(
				"Query result %d, dataset %d, dimension '%s', doesn't have a"
				" variable for role '%s'", pEnt->nQueryId, iDs, pDim->sId,
				sRole
			);
		
		for(i = 0; i < pDim->uVars; ++i){
			if(pDim->aVars[i] == pVar) *iVar = i;
		}
		if(*iVar == -1) das2c_IdlMsgExit("Logic error das2c_check_var_id");
	}
	
	return pVar;
}

/* ************************************************************************* */
/* API Function, careful with changes! */

#define D2C_VARS_MINA 3
#define D2C_VARS_MAXA 4
#define D2C_VARS_FLAG 0

/*
;+
; FUNCTION:
;  das2c_vars
;
; PURPOSE:
;  List the variables present in a physical dimension, in a das2 dataset.
;
; CALLING SEQUENCE:
;  Result = das2c_vars(query_id, ds_index, pdim, var)
;
; INPUTS:
;  query_id: The identification integer for the stored query result as
;            returned by das2c_readhttp() or das2c_queries.
;
;  ds_index: The dataset index, often 0.  See das2c_datasets() for details.
;
;  pdim:     Either the physical dimension index (long), or the dimension's
;            name (string).  For more infor see das2c_physdims().
;
; OPTIONAL INPUTS:
;  var:      Either the role name (string) or the var index (long).  This
;            argument is only required if summary information on a single 
;            variable is desired.
;
;            Variable role names are standardized.  The most common one is
;            'center' which represents the central point of a measurement
;            in a particular physical dimension.  The full set is:
;
;            'center', 'offest', 'min', 'max', 'width', 'mean', 'median',
;            'mode', 'reference', 'offset', 'max_error', 'min_error',
;            'uncertainty',  'std_dev', 'point_spread', 'weight'
;
; OUTPUT:
;  This function returns an array of structures providing an overview of
;  each stored result.  Output structures have the fields:
;
;    'id':     Long     ; The ID number for this variable.  Usage of
;                       ; role names instead of numbers is recommended.
;	
;    'name':   String   ; The name of the physical dimension for this variable
;
;    'type':   String   ; The IDL datatype of the values in this variable.
;
;    'role':   String   ; The role for this variable, for example 'max_error'
;
;    'units':  String   ; The units for values from this variable.
;
;    'shape':  8 Long64 ; The extent of this variable in the dataset indices.
;                       ; Values less than 0 mean the variable is degenerate
;                       ; or ragged in an index.
;
;    'size':   Long64   ; If this variable is directly backed by an array this
;                       ; is the total number of values in that array.  This
;                       ; value is 0 for virtual variables.
;
; TODO:
;  Should this function return !NULL if a requested role doesn't exist in a
;  physical dimension?
;
; EXAMPLES:
;  List summary of all variable roles for the 'time' dimension in dataset 0 of
;  query result 27
;    das2c_vars(27, 0, 'time')
;
;  List summary information of the 'center' variable for 'time' in dataset 0 for
;  query result 27
;    das2c_vars(27, 0, 'time', 'center')
;
;  List summary information for the first variable in the first physical
;  physical dimension of the first datasets, what ever it happens to be.
;    das2c_vars(27, 0, 0, 0)
;
; MODIFICATION HISTORY:
;  Written by: Chris Piker, 2020-03-10
;-
*/
static IDL_VPTR das2c_api_vars(int argc, IDL_VPTR* argv)
{
	/* Get/check Query ID */
	int iQueryId = das2c_args_query_id(argc, argv, 0);
	const DasIdlDbEnt* pEnt = das2c_check_query_id(iQueryId);
	
	/* Get/check dataset ID */
	int iDs = das2c_args_ds_id(argc, argv, 1);
	
	/* Get/check physical dimension ID/Name */
	char sDim[128] = {'\0'};
	int iDim = das2c_args_dim_id(argc, argv, 2, sDim, 127);
	const DasDim* pDim = das2c_check_dim_id(pEnt, iDs, &iDim, sDim, 127);
	
	const DasVar* pTheVar = NULL;
	char sRole[64] = {'\0'};
	int iVar = -1;
	
	if(argc > 3){
		iVar = das2c_args_var_id(argc, argv, 3, sRole, 63);
		pTheVar = das2c_check_var_id(pEnt, iDs, pDim, &iVar, sRole, 63);
	}
		
	/* See if they want just one var or many */
	IDL_MEMINT dims = 1;
	if(pTheVar == NULL) dims = pDim->uVars;
	
	IDL_VPTR pRet;  /* the to-be-returned structure */
	
	/* Returns pRet->value.s.arr.data */
	das2c_VarSummary* pData = (das2c_VarSummary*) IDL_MakeTempStruct(
		g_das2c_pVarSumDef, /* The opaque structure definition */
		1,                   /* Number of dimesions */
		&dims,               /* Size of each dimension, (only one dimension) */
		&pRet,               /* The actual structure variable */
		TRUE                 /* Zero out the array */
	);
	
	const DasVar* pVar = NULL;
	const DasAry* pAry = NULL;
	size_t u = 0, r = 0;
	int nRank = -1;
	ptrdiff_t shape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	
	for(u = 0; u < pDim->uVars; ++u){
		pVar = pDim->aVars[u];
		if(pVar == NULL) das2c_IdlMsgExit("Logic error, das2c_vars");
		
		/* If we have a single role to report and this ain't it, continue */
		if((pTheVar != NULL)&&(pVar != pTheVar)) continue;
		
		pData->id = u;
		IDL_StrStore(&(pData->name), pDim->sId);
		IDL_StrStore(&(pData->role), pDim->aRoles[u]);
		IDL_StrStore(&(pData->units), Units_toStr(pVar->units));
		
		nRank = DasVar_shape(pVar, shape);
		for(r = 0; r < IDL_MAX_ARRAY_DIM; ++r){ 
			if(r < nRank) pData->shape[r] = shape[r];
			else pData->shape[r] = DASIDX_UNUSED;
		}
		
		/* Add real value size for non-virtual variables */
		pData->size = 0;
		if( (pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData->size += DasAry_size(pAry);
				
		if(pTheVar != NULL) break;
		++pData;
	}
	
	return pRet;
}
