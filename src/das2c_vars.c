/* Copyright (C) 2020 Chris Piker <chris-piker@uiowa.edu>
 *                    
 * This file is part of das2dlm, an Interactive Data Language (IDL) binding
 * for the das2C library.  IDL is a trademark of Harris Geospatial Solutions,
 * Inc.  The shared object generated by this code may be loaded by main 
 * programs, or other shared objects, even those with closed source licenses.
 *
 * das2dlm is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 2.1 as published
 * by the Free Software Foundation.
 *
 * das2dlm is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 2.1 along with libdas2; if not, see <http://www.gnu.org/licenses/>.
 */


void das2c_vtype_2_idltype(das_val_type vt, size_t vsize, char* sBuf, size_t uLen)
{
	switch(vt){
	case vtUnknown: snprintf(sBuf, uLen, "BYTE(%zu)", vsize); return;
	case vtByte:    strncpy(sBuf, "BYTE", uLen);              return;
	case vtUShort:  strncpy(sBuf, "UINT", uLen);              return;
	case vtShort:   strncpy(sBuf, "INT", uLen);               return;
	case vtInt:     strncpy(sBuf, "LONG", uLen);              return;
	case vtLong:    strncpy(sBuf, "LONG64", uLen);            return;
	case vtFloat:   strncpy(sBuf, "FLOAT", uLen);             return;
	case vtDouble:  strncpy(sBuf, "DOUBLE", uLen);            return;
	case vtTime:    strncpy(sBuf, "DAS2C_TIME", uLen);        return;
	case vtText:    strncpy(sBuf, "STRING", uLen);            return;
	default:
		strncpy(sBuf, "NOT_DLM_COMPAT", uLen);
	}
}

/* ************************************************************************* */
/* Output structure definition.  Since only variables from the same dataset
   are used together we can trim the shape array, unfortunatly IDL DLMs have
	can't access LIST() or MAP() so have to repeate var definitions for every
	dataset size.  */
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_1[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},    /* ID items */
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},

	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},  /* info */
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},			
	{"SHAPE",   g_aShape1, (void*)IDL_TYP_LONG64},

	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},  /* contents */
	{0}
};
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_2[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape2, (void*)IDL_TYP_LONG64},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_3[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape3, (void*)IDL_TYP_LONG64},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_4[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape4, (void*)IDL_TYP_LONG64},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_5[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape5, (void*)IDL_TYP_LONG64},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_6[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape6, (void*)IDL_TYP_LONG64},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_7[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape7, (void*)IDL_TYP_LONG64},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};
static IDL_STRUCT_TAG_DEF DAS2C_VAR_tags_8[] = {
   {"QUERY",   NULL,      (void*)IDL_TYP_LONG},
	{"DSET",    NULL,      (void*)IDL_TYP_LONG},
	{"PDIM",    NULL,      (void*)IDL_TYP_STRING},
	{"VAR",     NULL,      (void*)IDL_TYP_STRING},
	{"UNITS",   NULL,      (void*)IDL_TYP_STRING},
	{"TYPE",    NULL,      (void*)IDL_TYP_STRING},
	{"SHAPE",   g_aShape8, (void*)IDL_TYP_LONG64},
	{"N_VALS",  NULL,      (void*)IDL_TYP_LONG64},
	{0}
};

typedef struct _das2c_var_data_s1{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[1];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data1;

typedef struct _das2c_var_data_s2{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[2];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data2;

typedef struct _das2c_var_data_s3{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[3];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data3;

typedef struct _das2c_var_data_s4{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[4];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data4;

typedef struct _das2c_var_data_s5{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[5];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data5;

typedef struct _das2c_var_data_s6{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[6];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data6;

typedef struct _das2c_var_data_s7{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[7];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data7;

typedef struct _das2c_var_data_s8{
	IDL_LONG   query;
	IDL_LONG   dset;
	IDL_STRING pdim;
	IDL_STRING var;
	IDL_STRING units;
	IDL_STRING type;
	IDL_LONG64 shape[8];
	IDL_LONG64 n_vals;
} DAS2C_VAR_data8;


static IDL_StructDefPtr DAS2C_VAR_pdef_1;
static IDL_StructDefPtr DAS2C_VAR_pdef_2;
static IDL_StructDefPtr DAS2C_VAR_pdef_3;
static IDL_StructDefPtr DAS2C_VAR_pdef_4;
static IDL_StructDefPtr DAS2C_VAR_pdef_5;
static IDL_StructDefPtr DAS2C_VAR_pdef_6;
static IDL_StructDefPtr DAS2C_VAR_pdef_7;
static IDL_StructDefPtr DAS2C_VAR_pdef_8;

static void define_DAS2C_VAR()
{
	DAS2C_VAR_pdef_1 = IDL_MakeStruct("DAS2C_VAR_1", DAS2C_VAR_tags_1);
	DAS2C_VAR_pdef_2 = IDL_MakeStruct("DAS2C_VAR_2", DAS2C_VAR_tags_2);
	DAS2C_VAR_pdef_3 = IDL_MakeStruct("DAS2C_VAR_3", DAS2C_VAR_tags_3);
	DAS2C_VAR_pdef_4 = IDL_MakeStruct("DAS2C_VAR_4", DAS2C_VAR_tags_4);
	DAS2C_VAR_pdef_5 = IDL_MakeStruct("DAS2C_VAR_5", DAS2C_VAR_tags_5);
	DAS2C_VAR_pdef_6 = IDL_MakeStruct("DAS2C_VAR_6", DAS2C_VAR_tags_6);
	DAS2C_VAR_pdef_7 = IDL_MakeStruct("DAS2C_VAR_7", DAS2C_VAR_tags_7);
	DAS2C_VAR_pdef_8 = IDL_MakeStruct("DAS2C_VAR_8", DAS2C_VAR_tags_8);
}

static IDL_StructDefPtr das2c_get_var_pdef(int nRank)
{
	switch(nRank){
	case 1: return DAS2C_VAR_pdef_1;
	case 2: return DAS2C_VAR_pdef_2;
	case 3: return DAS2C_VAR_pdef_3;
	case 4: return DAS2C_VAR_pdef_4;
	case 5: return DAS2C_VAR_pdef_5;
	case 6: return DAS2C_VAR_pdef_6;
	case 7: return DAS2C_VAR_pdef_7;
	case 8: return DAS2C_VAR_pdef_8;
	default:return NULL;
	}
}

/* Given a variable structure pointer, return items often needed for
   working with variables */
		
DasVar* das2c_arg_to_var(
	int argc, IDL_VPTR* argv, int iArg, int* piQuery, int* piDs, 
	DasDs** ppDs, DasDim** ppDim
){
	int iQuery = -1;
	int iDs = -1;
	DasDs* pDs = NULL;
	DasDim* pDim = das2c_arg_to_dim(argc, argv, iArg, &iQuery, &iDs, &pDs);
	if(pDs == NULL) return NULL;
	
	/* Get the PDIM string field */
	IDL_VPTR pVar = argv[iArg];
	
	if(pVar->type != IDL_TYP_STRUCT)
		das2c_IdlMsgExit("Argument %d is not a structure", iArg+1);
	
	/* Ducktyping: Any field names 'VAR' that has type string will do */
	IDL_VPTR pFakeVar = NULL;
	IDL_MEMINT nOffset = IDL_StructTagInfoByName(
		pVar->value.s.sdef, "VAR", IDL_MSG_LONGJMP, &pFakeVar
	);
	
	if(pFakeVar->type != IDL_TYP_STRING)
		das2c_IdlMsgExit("Field VAR in argument %d is not a string", iArg+1);
	
	UCHAR* pData = pVar->value.s.arr->data + nOffset;
	
	const char* sRole = IDL_STRING_STR( (IDL_STRING*)pData);
	if((sRole == NULL)||(sRole[0] == '\0'))
		das2c_IdlMsgExit(
			"Field VAR is empty in the structure at argument %d", iArg+1
		);
	
	/* D, Rust, etc. would not allow this... */
	DasVar* pDasVar = (DasVar*) DasDim_getVar(pDim, sRole);
	
	if(pDasVar == NULL)
		das2c_IdlMsgExit(
			"Mismatch, VAR '%s' is not present in query %d, dataset %d, "
			"dimenison %s", sRole, iQuery, iDs, DasDim_id(pDim)
		);
		
	if(piQuery != NULL) *piQuery = iQuery;
	if(piDs    != NULL) *piDs    = iDs;
	if(ppDs    != NULL) *ppDs    = pDs;	
	if(ppDim   != NULL) *ppDim   = pDim;

	return pDasVar;
}
	
		
/* ************************************************************************* */
/* API Function, careful with changes! */

#define D2C_VARS_MINA 1
#define D2C_VARS_MAXA 2
#define D2C_VARS_FLAG 0

/*
;+
; FUNCTION:
;  das2c_vars
;
; PURPOSE:
;  List the variables present in a physical dimension, in a das2 dataset.
;
; CALLING SEQUENCE:
;  Result = das2c_vars(pdim)
;  Result = das2c_vars(pdim, var)
;
; INPUTS:
;  pdim: A DAS2C_PDIM structure as returned by das2c_pdims().
;
; OPTIONAL INPUTS:
;  var:      A variables role name (string). This argument is only needed
;            if information on a single variable is desired.
;
;            Variable role names are standardized.  The most common one is
;            'center' which represents the central point of a measurement
;            in a particular physical dimension.  The full set is:
;
;            'center', 'offest', 'min', 'max', 'width', 'mean', 'median',
;            'mode', 'reference', 'offset', 'max_error', 'min_error',
;            'uncertainty',  'std_dev', 'point_spread', 'weight'
;
; OUTPUT:
;  This function returns an array of structures providing an overview of each
;  variable in this physical dimension.  Output structures have the following
;  fields:
;
;    QUERY (Long)       The query ID of this dataset, starts from 1
;
;    DSET  (Long)       The ID number of this dataset, starts from 0
;
;    PDIM  (String)     The name of this physical dimension, ex: 'time'
;
;    VAR   (String)     The role name for this variable.  These are standardize.
;                       See the optional inputs section above for details.
;
;    UNITS (String)     The units for values from this variable.  The default
;                       units format follows the fortran convention of using
;                       two astricks (**) to indicate exponentiation.
;
;    TYPE  (String)     The IDL datatype of the output of das2c_data() calls
;                       for this variable.  Will be one of the strings:
;
;                       'BYTE', 'BYTE(N)', 'UINT', 'INT', 'LONG', 'LONG64'
;                       'FLOAT', 'DOUBLE', 'DAS2C_TIME', 'STRING'
;
;                       Most of the strings are just IDL type names and are thus
;                       self explianitory.  The type string 'BYTE(N)' indicates
;                       fixed length byte arrays, here N will actually be an 
;                       integer greater than 1.
;	
;                       The string DAS2C_TIME means that the return value from
;                       a das2c_data call will be an array of DAS2C_TIME structure
;                       which contains broken down times.  Note most servers send
;                       time values as type DOUBLE not as a time structure.
;
;    SHAPE (Long64 Arr) This array is DAS2C_DSET.RANK elements long. It provides
;                       information on the internal storage of the variable that
;                       is of use when calling das2c_data().
;                      
;                       While all variables have the same shape in index space
;                       as the overall dataset, they may be backed by arrays 
;                       that are actually smaller than the overall dataset shape
;                       would indicate.  Also, some variables may generate data 
;                       from a sequence calculation and thus do not have a 
;                       backing array at all.  Each element of SHAPE has one of
;                       the following values:
;                      
;                         N:  An integer >= 0 means that this variable produces
;                             potentially unique values in this index when 
;                             calling das2c_data().  This integer will be the
;                             same as the corresponding value from 
;                             DAS2C_DSET.SHAPE.
;
;                         -3: The variable is degenerate in this index, so
;                             any integer used for this index will not affect
;                             the output of a das2c_data() call.  This is 
;                             common for variables in coordinate dimensions.
;                             (see DAS2C_PDIM.USE)
;                       
;                         -1: The variable has no internal storage at all 
;                             corresponding to this index.  It is a sequence.
;                             The output from a das2c_data() call is calculated
;                             based on the index values supplied, or indicated,
;                             by the caller.
;
;    'N_VALS': Long64   If this variable is directly backed by an array this
;                       is the total number of real storage locations in that
;                       array.
;
; If a variable is requested for a role that doesn't exist in the given physical
; dimension, !NULL is returned.
;
; EXAMPLES:
;  List summary of all variable roles for the 'time' dimension in dataset 0 of
;  query result 27
;    query = das2c_query(27)
;    ds = das2c_datasets(0)
;    pd_time = das2c_pdims(ds, 'time')
;
;    das2c_vars(pd_time)
;
;  List summary information of the 'center' variable for the 'time' dimension
;  above:
;    das2c_vars(pd_time, 'center')
;
; MODIFICATION HISTORY:
;  Written by: Chris Piker, 2020-03-13
;-
*/
static IDL_VPTR das2c_api_vars(int argc, IDL_VPTR* argv)
{
	/* Get the pdim, the ds nmuber and the entry number */
	int iQuery = -1;
	int iDs = -1;
	
	DasDs*  pvDs = NULL;
	const DasDim* pDim = das2c_arg_to_dim(argc, argv, 0, &iQuery, &iDs, &pvDs);
	const DasDs* pDs = pvDs;
	
	int nDsRank = DasDs_rank(pDs);
	
	const char* sDim = DasDim_id(pDim);
	const char* sRole = NULL;
	
	const DasVar* pTheVar = NULL;
	
	if(argc > 1){
		if(argv[1]->type != IDL_TYP_STRING)
			das2c_IdlMsgExit("Variable role string exected for argument 2");
		
		sRole = IDL_VarGetString(argv[1]);
		if(*sRole == '\0') das2c_IdlMsgExit("Variable role name is empty");
		
		pTheVar = DasDim_getVar(pDim, sRole);
		if(pTheVar == NULL) 
			return IDL_GettmpNULL();
	}
		
	/* See if they want just one var or many */
	IDL_MEMINT dims = 1;
	if(pTheVar == NULL) dims = pDim->uVars;
	
	IDL_VPTR pRet;  /* the to-be-returned structure */
	
	/* AGGG! Lack of access to IDL_TYP_OBJREF rases it's ugly head again!  */
	/* We need different code paths because there are 8 different possible */
	/* casts for the data pointer!!!! */

	/* Returns pRet->value.s.arr.data */
	void* pData = IDL_MakeTempStruct(
		das2c_get_var_pdef(nDsRank),  /* The opaque structure definition */
		1,                   /* Number of dimesions */
		&dims,               /* Size of each dimension, (only one dimension) */
		&pRet,               /* The actual structure variable */
		TRUE                 /* Zero out the array */
	);
	
	DAS2C_VAR_data1* pData1 = NULL;
	DAS2C_VAR_data2* pData2 = NULL;
	DAS2C_VAR_data3* pData3 = NULL;
	DAS2C_VAR_data4* pData4 = NULL;
	DAS2C_VAR_data5* pData5 = NULL;
	DAS2C_VAR_data6* pData6 = NULL;
	DAS2C_VAR_data7* pData7 = NULL;
	DAS2C_VAR_data8* pData8 = NULL;
	switch(nDsRank){
	case 1: pData1 = (DAS2C_VAR_data1*)pData; break;
	case 2: pData2 = (DAS2C_VAR_data2*)pData; break;
	case 3: pData3 = (DAS2C_VAR_data3*)pData; break;
	case 4: pData4 = (DAS2C_VAR_data4*)pData; break;
	case 5: pData5 = (DAS2C_VAR_data5*)pData; break;
	case 6: pData6 = (DAS2C_VAR_data6*)pData; break;
	case 7: pData7 = (DAS2C_VAR_data7*)pData; break;
	case 8: pData8 = (DAS2C_VAR_data8*)pData; break;
	default: das2c_IdlMsgExit("Logic error2, das2c_vars");  break;
	}
	
	const DasVar* pVar = NULL;
	const DasAry* pAry = NULL;
	size_t u = 0, r = 0;
	/*int nRank = -1; */
	ptrdiff_t shape[DASIDX_MAX] = DASIDX_INIT_UNUSED;
	
	/* Get the data type */
	char sIdlType[64] = {'\0'};
	
	for(u = 0; u < pDim->uVars; ++u){
		pVar = pDim->aVars[u];
		if(pVar == NULL) das2c_IdlMsgExit("Logic error3, das2c_vars");
		
		/* If we have a single role to report and this ain't it, continue */
		if((pTheVar != NULL)&&(pVar != pTheVar)) continue;
		
		DasVar_shape(pVar, shape);
		das2c_vtype_2_idltype(pVar->vt, pVar->vsize, sIdlType, 63);
		
		switch(nDsRank){
		
		case 1:
		pData1->query = iQuery;
		pData1->dset  = iDs;
		IDL_StrStore(&(pData1->pdim), sDim);
		IDL_StrStore(&(pData1->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData1->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData1->type), sIdlType);
		for(r=0; r<nDsRank; ++r) pData1->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData1->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData1->n_vals += DasAry_size(pAry);
		++pData1;
		break;
		
		case 2:
		pData2->query = iQuery;
		pData2->dset  = iDs;
		IDL_StrStore(&(pData2->pdim), sDim);
		IDL_StrStore(&(pData2->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData2->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData2->type), sIdlType);
		for(r=0; r<nDsRank; ++r) pData2->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData2->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData2->n_vals += DasAry_size(pAry);
		++pData2;
		break;

		case 3:
		pData3->query = iQuery;
		pData3->dset  = iDs;
		IDL_StrStore(&(pData3->pdim), sDim);
		IDL_StrStore(&(pData3->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData3->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData3->type), sIdlType);
		for(r=0; r<nDsRank; ++r) pData3->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData3->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData3->n_vals += DasAry_size(pAry);
		++pData3;
		break;
	
		case 4:
		pData4->query = iQuery;
		pData4->dset  = iDs;
		IDL_StrStore(&(pData4->pdim), sDim);
		IDL_StrStore(&(pData4->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData4->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData4->type), sIdlType);
		for(r=0; r<nDsRank; ++r) pData4->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData4->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData4->n_vals += DasAry_size(pAry);
		++pData4;
		break;
	
		case 5:
		pData5->query = iQuery;
		pData5->dset  = iDs;
		IDL_StrStore(&(pData5->pdim), sDim);
		IDL_StrStore(&(pData5->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData5->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData5->type), sIdlType);
		for(r=0; r<nDsRank; ++r) pData5->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData5->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData5->n_vals += DasAry_size(pAry);
		++pData5;
		break;
	
		case 6:
		pData6->query = iQuery;
		pData6->dset  = iDs;
		IDL_StrStore(&(pData6->pdim), sDim);
		IDL_StrStore(&(pData6->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData6->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData6->type), sIdlType);
		for(r=0; r<nDsRank; ++r) pData6->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData6->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData6->n_vals += DasAry_size(pAry);
		++pData6;
		break;
	
		case 7:
		pData7->query = iQuery;
		pData7->dset  = iDs;
		IDL_StrStore(&(pData7->pdim), sDim);
		IDL_StrStore(&(pData7->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData7->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData7->units), sIdlType);
		for(r=0; r<nDsRank; ++r) pData7->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData7->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData7->n_vals += DasAry_size(pAry);
		++pData7;
		break;
	
		case 8:
		pData8->query = iQuery;
		pData8->dset  = iDs;
		IDL_StrStore(&(pData8->pdim), sDim);
		IDL_StrStore(&(pData8->var), pDim->aRoles[u]);
		IDL_StrStore(&(pData8->units), Units_toStr(pVar->units));
		IDL_StrStore(&(pData8->units), sIdlType);
		for(r=0; r<nDsRank; ++r) pData8->shape[(nDsRank-1)-r] = shape[r];  /* Shape inversion */
		pData8->n_vals = 0;
		if((pAry = DasVarAry_getArray((DasVar*)pVar)) != NULL)
			pData8->n_vals += DasAry_size(pAry);
		++pData8;
		break;
	
		default: das2c_IdlMsgExit("Logic error4, das2c_vars");
		}
		
		if(pTheVar != NULL) break;
	}
	
	return pRet;
}
